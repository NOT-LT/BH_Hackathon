 What Does “Universal Acceptance” Mean? Some software does not recognize or correctly process all domain names and all email addresses. Domain names can include strings in the top-level position that are longer than the older familiar ones, and domain names and email addresses can now use characters drawn from a much larger Unicode-based repertoire than traditional ASCII1. Universal Acceptance (UA) is the state in which all valid domain names and email addresses are accepted, validated, stored, processed, and displayed correctly and consistently. The Universal Acceptance Steering Group (UASG) is a community-led initiative working on creating awareness and identifying and resolving problems associated with the universal acceptance of all domain names and email addresses. Its goal is to help ensure a consistent and positive experience for Internet users globally. It is supported by ICANN (the Internet Corporation for Assigned Names and Numbers) and has participants from more than 200 organisations around the world, including Aﬁlias, Apple, CNNIC, GoDaddy, Google, Microsoft, and Verisign. For more information on the UASG and recent developments, visit: www.uasg.tech. Software and online services support Universal Acceptance when they oﬀer the capabilities listed above for all domains and email names. 1 ASCII is the character encoding historically used on the Internet, deﬁned in the Internet standard RFC 20 . Unicode is deﬁned by the Unicode Consortium . This Quick Guide describes the UASG Recommendations for achieving Universal Acceptance in the ﬁve contexts—Accept, Validate, Store, Process, and Display—in which systems encounter domain names and email addresses. It is intended for executives and managers responsible for Information Technology or Software Product Engineering activities. It presents the UASG Recommendations at a high level without some of the detail that would be important to a software architect or engineer. For those details consult UASG 007, “ Normalization, Case Folding, and String Preparation 28 Case Folding and Mapping 30 Glossary and Other Resources 31 Glossary 31 RFCs and Key Standards 34 Key Standards 37 Online Resources 38  About This Document The Internet’s technologies, including its naming components, continually evolve and change. In recent years, new top-level domains (TLDs), some with traditional ASCII characters and some with non-ASCII characters (Internationalized Domain Names), have been approved by the Internet Corporation for Assigned Names and Numbers (ICANN). Examples include .nyc, .संगठन, .eco, and .католик. However, many applications and services have not been updated to manage this expanded range of TLDs. In addition, Internet email standards now allow non-ASCII characters in email addresses, so until software is upgraded, it will not properly handle these domains and addresses. This affects the user experience in multiple ways: ▪ ▪ Valid email addresses are not recognized or accepted. Domain names are mistakenly treated as search terms in the address bar of the browser. Until software recognizes and processes all domain names and email addresses – a state known as Universal Acceptance (UA) – it will not be possible to provide a consistent and positive experience for all Internet users. This document provides a broad introduction to Universal Acceptance and the efforts being made to assist in the development of Universal Acceptance-ready software. Target Audience This document is intended to introduce Universal Acceptance to a technical audience (developers, managers, and operators) that may be familiar with some aspects of Internet technology but not necessarily the details of how new IDNs, domain names, and email addresses affect the way in which they should be accepted, validated, stored, processed, and displayed. It represents a starting point for people with diverse technical backgrounds to begin their exploration of Universal Acceptance.  Background Concepts Domain Names A domain name is a human-friendly identifier for computers and networks on the Internet. It is customarily represented as a sequence of text labels separated by “dots” (the period or full-stop punctuation mark); for example, www.example.tld. Each label represents a level in the Domain Name System (DNS) hierarchy. At the highest level or “root” of the hierarchy are top-level domain (TLD) labels such as com, jp, and বাাংলা, which appear at the end of a domain name. Because they appear at the end, TLDs are sometimes called “suffixes.” Proceeding down the DNS hierarchy from the root, the next label identifies a subdomain of the TLD, commonly called a second-level domain; the label after that identifies a subdomain of the second-level domain, commonly called a third-level domain; and so on, with each of the labels separated from its neighbor by a dot. For example, a domain name with three levels might look like this: Country Code Top-level Domains (ccTLDs) Some TLDs are delegated to specific countries or territories. These are called country code top-level domains (ccTLDs). In the past, all ccTLDs were two letters matching the ISO 3166 two-letter code assigned to the country or territory by the International Organization for Standardization. Since 2010, there have also been internationalized ccTLDs that represent the name of a country or territory in that country or territory’s own script. Generic Top-level Domains (gTLDs) Most TLDs that are not ccTLDs are called generic top-level domains (gTLDs), which are either open to anyone or restricted to the members of a defined community. These include the familiar .com, .net, and .org as well as more recent additions. Through the New gTLD Program – an initiative coordinated by ICANN – the Domain Name System (DNS) has expanded exponentially through the introduction of new generic top-level domains. These new gTLDs can represent brands, communities of interest, geographic areas (cities, regions), and more.  Domain Name Internationalization Domain names were originally limited to a subset of ASCII characters (letters a-z, digits 0-9, and the hyphen “-“). Since the earliest .com registration, symbolics.com in 1985, the number and characteristics of domain names have expanded to reflect the needs of the everincreasing global use of the Internet as a communal resource. Today, the majority of Internet users are non-English speakers; however, the dominant language used on the Internet is English. To help with the internationalization of the Internet, in 2003 the Internet Engineering Task Force (IETF) started releasing standards providing technical guidelines for the deployment of Internationalized Domain Names (IDNs) through a translation mechanism to support non-ASCII representations of domain names in any Unicode-supported script (e.g., 普遍接受-测试.世界, ua-test.‫كاثوليك‬,etc.). The ICANN Board of Directors approved the process to introduce new IDN ccTLDs in October 2009, with the first IDN ccTLDs added to the root zone in May 2010. In June 2011, the Board approved and authorized the launch of the New gTLD Program, which included new ASCII as well as IDN TLDs. The first batch of TLDs from this program was added to the root zone in 2013. The Need for Universal Acceptance (UA) A decade after the IETF released its IDN-related guidelines, and through the ICANN New gTLD Program, more than 1,000 new TLDs are now active. However, some software and applications remain outdated and are unable to handle these new TLDs. This causes problems for Internet users, including those who use non-ASCII characters and scripts. Universal Acceptance ensures that all valid domain names and email addresses are accepted, validated, stored, processed, and displayed correctly and consistently by all Internet-enabled applications, devices, and systems. For example, every valid web address resolves to the expected resource on the correct website and every valid email address results in mail delivery to the expected recipient. The Universal Acceptance Steering Group (UASG) is an Internet community initiative, supported by ICANN, that is tasked with undertaking activities that will effectively promote Universal Acceptance and help ensure a consistent and positive experience for Internet users globally. U-labels and A-labels Domain names that use non-ASCII characters are called Internationalized Domain Names (IDNs). The internationalized portion of a domain name can be in any label—not just the TLD. Since the DNS itself previously only used ASCII, it was necessary to create an additional encoding to allow non-ASCII Unicode code points to be represented as ASCII strings. The algorithm that implements this Unicode-to-ASCII encoding is called Punycode; the output strings are called A-Labels. A-Labels can be distinguished from an ordinary ASCII label because they always start with the following four characters: xn--  These characters are called the ACE prefix.1 The Punycode transformation is reversible: it can transform from Unicode to an A-Label and from an A-label back to a string of Unicode characters (known as a U-Label). The only standard use of the Punycode algorithm is for expressing internationalized domains. While one could hypothetically encode other UTF-8 strings using Punycode, that would be non-standard and would not interoperate with other systems. Examples of (imaginary) IDNs U-label version A-label version example.みんな example.xn--q9jyb4c 大坂.info xn--uesx7b.info みんな.大坂 xn--q9jyb4c.xn--uesx7b Email Address Internationalization (EAI) Email addresses contain two parts: ▪ ▪ A local part (before the “@” character). A domain part (after the “@” character). Because both left-to-right (LTR) and right-to-left (RTL) scripts can be used in email addresses and domain names, “before” and “after” should be understood with respect to the directionality of the script. Examples of (imaginary) EAI Addresses user@example.みんな Uses IDN TLD user@大坂.info Uses IDN second-level domain 用戶@example.lawyer Uses Unicode local part and new gTLD ASCII Compatible Encoding (ACE) prefix which distinguishes Punycode-encoded labels from other ASCII labels. 1  Example of Right-to-Left text in an EAI Address LTR RTL In an internationalized email address, the domain part can contain any domain name, including those with new TLDs, and can contain Unicode U-labels. The local part is not a domain name and can in principle contain nearly any Unicode character, although in practice mail systems will limit the characters used in their mailbox names. The term Email Address Internationalization (EAI) is often used to describe the use of internationalized addresses in email. Dynamic Link Generation (Linkification) Modern software such as popular word processing or spreadsheet applications sometimes allows a user to create a hyperlink simply by typing in a string that looks like a web address, email address, or network path. For example, typing “www.icann.org” into an email message may automatically result in a clickable link to  if the app recognizes “www.” as a special prefix or “.org” as a special suffix. When it is used, linkification should work consistently for all well-formed web addresses, email addresses, or network paths, and not just some. Accurate linkification is difficult and depends on the context of the text (for example, in some languages “www” doesn’t indicate a web address), so it is not further addressed here. The Dynamic Nature of the Root Zone Registry The DNS is a large distributed database divided into sections called zones. The section that contains all TLDs is called the root zone because it is conceptually at the root of the tree of DNS names. All DNS zones, including the root zone, are updated as required. As new TLDs are added or old TLDs are retired, their names are added to or removed from the root zone. This means that any fixed list of TLDs, such as a list stored in an application or in a file, will eventually and inevitably become out of date. To reliably validate the TLD in a domain name, software can check it online with a DNS query, or if it uses a file, refresh the file on a regular basis. These are both described in more detail later.  Universal Acceptance in Action Five Criteria of Universal Acceptance Universal Acceptance is the state in which all valid domain names and email addresses are accepted, validated, stored, processed, and displayed correctly and consistently by all Internet-enabled applications, devices and systems. The five criteria of Universal Acceptance are described below. 1. Accept2 Accepting occurs whenever an email address or a domain name is received as a string of characters from a user interface, from a file, or from an API used by a software application or online service. Applications and services allow domain names and email addresses to be: ▪ Entered via user interfaces, or ▪ Received from other applications and services via APIs. 2. Validate3 Validation may occur in many places whenever an email address or a domain name is either received or emitted as a string of characters by an application or online service. Validation is intended to ensure that the entered information is either valid or at least definitely not invalid. Validation ensures the information has the correct syntax and may make other checks. For domain names and email addresses, many programmers have traditionally relied on ad hoc validation methods such as checking that a TLD is within length limits, or that the characters are from the ASCII character set. However, these methods are based on assumptions that are no longer applicable because the Internet is changing: ▪ ▪ ▪ Domain names and email addresses can now include nonASCII Unicode characters. The list of TLDs is changing. Any label in a domain name, including the TLD label, can be up to 63 characters long.4 It remains possible to validate TLDs using other techniques, as described later. Accepting is treated as distinct from Validating in this document. In practice, the actions may overlap. 3 Accepting and Processing are treated as distinct from Validating in this document. In practice, the actions may overlap. 4 The 63-character length limit applies to the label itself if it is an ASCII label, or to the A-label form of the label if it is an IDN. 2  3. Store Storage occurs when an email address or a domain name is stored as a string of characters in a database or file used by a software application or online service and later retrieved by the same or other software applications. Applications and services might require long-term and/or transient storage of domain names and email addresses. Regardless of the lifetime of the data, it must be stored in: ▪ ▪ Formats defined by an Internet-standard Request for Comments (RFC), or (less desirably) Alternative formats that can be translated to and from RFCdefined formats. Although Unicode in DNS names and email addresses are stored as UTF-8, other formats may be encountered in legacy code. See the Good Practices section below. 4. Process5 Processing occurs when an email address or a domain name is used by an application or service to perform an activity such as searching or sorting a list, or is transformed into an alternative format (such as turning U-labels into A-labels). Additional validation may occur during processing. The ways in which email addresses and domain names may be processed is limited only by the imagination of application developers, but it is important not to make assumptions (e.g., that email addressed to pākehā@tetaurawhiri.govt.nz is intended for a person in New Zealand) that depend on policies outside of the DNS. 5. Display The Display action occurs when an email address or a domain name is rendered within a user interface. Displaying domain names and email addresses is usually, but not always, straightforward when the scripts used in the name or address are supported in the underlying operating system and when the strings are stored in Unicode.6 If these conditions are not met, application-specific transformations may be required. Further, even if the underlying operating system does support the strings, display can be complicated if, for example, RTL and LTR scripts are mixed, or the overall directionality of text is unclear. Processing is treated as distinct from Validating in this document. In practice, the actions may overlap. 5 It is important to recognize that display is not straightforward, even when these conditions are met for some complex scripts. 6  User Scenarios The examples and definitions above may give the impression that Universal Acceptance is only about computer systems and online services. The reality, however, is that it’s also about the people using those systems and services. Below are some examples of activities that require Universal Acceptance: Registering a new TLD An organization adopts a “brand” TLD to offer its customers a differentiated customer experience by providing email addresses in the format: customername @example.brand. Universal Acceptance means: ▪ Web sites and applications accept these “@example.brand” email addresses as they would with older TLDs such as .com, .net, .org. Accessing a gTLD A user accesses a website whose domain name contains a new TLD by typing an address into a browser or clicking a link in a document. Universal Acceptance means: ▪ Even though the TLD is new, the user’s browser displays the web address in its native form and accesses the site as the user expects. The browser does not display domain names as A-labels to the user unless it benefits the user in some way. Using an email address containing a new gTLD as an online identity A user acquires an email address with the domain portion using a new gTLD and uses this email address as their identity for accessing their bank and airline loyalty accounts. Universal Acceptance means: ▪ Even though the domain used in the email address is new, the bank or airline site accepts the address the same way in which it accepts an address in an older TLD such as .biz or .eu. Accessing an IDN A user accesses an IDN URL by typing the URL into a browser or clicking a link in a document. Universal Acceptance means: ▪ Even if the domain name contains characters different than the language settings on the user’s computer, any browser the user wishes to use will display the web address as expected and access the site successfully.  Using an internationalized email address for email A user has acquired a new email address which includes non-ASCII characters in the domain name (e.g., īnfo@普 遍接受-测试.世界). Universal Acceptance means: ▪ The user can send to and receive from any email address, using any email client. Using an internationalized email address as an online identity A user acquires a non-ASCII email address and uses this email address as their identity for accessing their bank and airline loyalty accounts. Universal Acceptance means: ▪ The bank or airline site accepts the new identity exactly as if it were any other email identity. Dynamically creating a hyperlink in an application A user types a web address into a document or email message. Universal Acceptance means: ▪ The rules used by the application to automatically generate a hyperlink are the same if the address is non-ASCII or contains a new TLD. Developing an application A developer writes an app that accesses web resources. Universal Acceptance means: ▪ The tools used by the developers include libraries that enable Universal Acceptance by supporting new TLDs and IDNs. Nonconformance to Universal Practices The following are considered to be poor practice: ✖ Displaying A-labels to the user without a corresponding user benefit, such as to show the mapping between a U-label and a A-label. ✖ Requiring a user to enter A-labels when signing up for a new email address or requiring a user to enter A-labels when signing up for a new hosted domain. ✖ Validating the syntax of domain name or email address using out of date criteria or non-authoritative online domain name resources. ✖ Using an outdated list of TLDs even though new TLDs are regularly being added and deleted. ✖ Exposing internal use of A-labels to users. For example, converting domains in EAI addresses to A-labels when replying to an EAI user.  ✖ Treating some domain names as search terms rather than as domain names because the application does not recognize them as such. ✖ Setting spam blockers to automatically block entire (new) TLDs without evidence of abuse. Technical Requirements for UA Readiness For an application or website to be UA-ready, it must meet a variety of requirements. High-Level Requirements An application or service that supports Universal Acceptance (UA): 1. Supports all domain names regardless of length or character set. See RFC 5892. 2. Allows all of the character sets that are valid for domain names and email addresses. Accept Unicode code points as well as ASCII. 3. Can correctly render all code points in Unicode strings. See RFC 3490. Note that Unicode regularly adds new code points, so this is a moving target. 4. Can correctly render right-to-left (RTL) strings such as those in Arabic and Hebrew. For information about RTL scripts, see RFC 5893. 5. Can communicate data between applications and services in UTF-8 and, where needed, other encodings that can be converted to and from UTF-8. For information about UTF-8, see RFC 3629. 6. Offers public and private APIs that support UTF-8. Private APIs apply only to inter-service calls by the same vendor. 7. Treats EAI addresses correctly. In particular, doesn’t convert IDNs in addresses to A-labels. 8. Can send email to and receive email from recipients regardless of domain name or character set. See RFC 6530.  9. Stores user data in formats that support Unicode and is convertible to and from UTF-8. Such conversions would be visible only to the operator of the product or service. 10. Supports all top-level domain names in the authoritative ICANN TLD list regardless of length or character set. See the authoritative list at  Developer Considerations Since many existing software systems contain hardcoded assumptions about domains and email addresses, code changes may be required to recognize IDNs, new TLDs, and EAI mail addresses. This section discusses how developers can incorporate code changes that will enable Universal Acceptance. Designing Software for Compatibility and Flexibility The Robustness Principle, as articulated by Jon Postel in RFC 793, is a general design guideline for software development: “Be conservative in what you do; be liberal in what you accept from others.” That is, be conservative in what you send: in any area in which a specification might be ambiguous or unclear, avoid anything that could surprise others. On the other hand, when receiving, accept anything that is plausibly valid. This does not mean changing code to work around clear mistakes in other implementations since that leads to an undocumented and “undebuggable” mess. Good Practices for Developing and Updating Software to Achieve UA-Readiness Accept ✔ Display names as Unicode whenever possible. Users should be allowed, but not required, to enter domain names as A-labels rather than U-labels. However, U-labels should be shown by default, with Alabels shown to the user only when it provides a benefit. ! Don’t generate EAI addresses with A-labels but do be able to handle them if presented by someone else’s software. ✔ Any user interface element requiring a user to type a domain name or email address must accept long names. ASCII domain names can have up to 63 characters in each label and can be in total up to 253 bytes. UTF-8 labels can be much longer than ASCII labels and the total length can be up to 670 bytes.  Remember that the UTF-8 code for most Unicode code points takes more than one byte. ▪ See RFC 1035. Validate ✔ Validate only as appropriate. Validate only if it is required for the operation of the application or service. This is the most reliable way to ensure that all valid domain names are accepted into your systems. ✔ Recognize that syntactically correct inputs may represent domain names or email addresses that are currently in use on the Internet. That may or may not be valid depending on the application. ! When you validate, consider the following: ▪ Verify the TLD portion of a domain name against an authoritative table. IANA publishes the list of top-level domains at:    See also:  ▪ Query the domain name against the DNS.  The GETDNS API  is a highly portable way to query the DNS.  Most operating systems also have a native DNS query API. ▪ Require repeated entry of an email address to detect typing errors. ▪ Validate the characters in labels by checking that each label follows the Internationalizing Domain Names in Applications (IDNA 2008) rules.  See RFC 5892 ▪ Limit validation of labels itself to a small number of whole-label rules defined in the RFCs.  See RFC 5894 ▪ Ensure that the product or feature handles numbers correctly.  For example: Arabic-Indic digit characters should be treated as numbers in numeric input fields, as well as ASCII digits.  Note that Arabic-Indic digits are valid in U-labels but are not considered equivalent to ASCII digits in that context.  Store ✔ Applications and services should support the most current Unicode standards. ✔ Information should be stored in the UTF-8 format whenever possible. Some systems may require legacy support for UTF-16 as well, but generally UTF-8 is preferred. UTF-7 is obsolete, and UTF-32 is too bulky for file storage. The strings should be normalized when appropriate (some normalization can in some context result in loss of information). ! Consider all end-to-end scenarios before converting between A-Labels and ULabels when storing. In new applications, it is better to maintain only U-Labels in a file or database, because it simplifies searching, sorting, and presentation. However, conversion may have implications when interoperating with older, non-Unicode-enabled applications and services. ✔ Tag email addresses and domain names as such in storage for easier access. Filing email addresses and domain names in the “author” field of a document or “contact info” in a log file have led to the loss of the original address. ✔ Regardless of the way addresses and domain names are stored, you must be able to match strings in multiple formats. For example, a search for example.みんなshould also find example.xn-q9jyb4c. Process ✔ Ensure all web server and MIME mail responses have UTF-8 specified in the content type. ✔ Specify UTF-8 in the web server http header. ▪ It is important to ensure that the encoding is specified on every response. ! Consider context before converting A-Labels to U-Labels and vice versa during processing. It is desirable to maintain only U-Labels in a file or database as it simplifies searching and sorting. However, conversion may have implications when interoperating with older, non-Unicode-enabled applications and services.  ✔ Ensure that the product or feature handles sort order, searches, and collation according to locale and language specifications, and that it addresses multilanguage searching and sorting. ✖ Don’t use percent encoding for labels in domain names: ▪ example.みんな is correct ▪ example.%E3%81%BF%E3%82%93%E3%81%AA is not correct. ✔ Since the Unicode standard is continually expanding, code points not defined when the application or service was created should be checked to ensure they don’t produce erroneous or confusing output. Missing fonts in the underlying operating system may result in non-displayable characters (frequently a small box is used to represent these), but this situation should not result in a crash or error message. ✔ Use supported Unicode-enabled APIs. ✔ Use the latest Internationalized Domain Names in Applications (IDNA 2008) Protocol and Tables documents for IDNs: ▪ RFC 5891 ▪ RFC 5892 ✔ Process text in UTF-8 format wherever possible. ✔ Coordinate upgrades of applications and the services they depend on. If the server is Unicode and client is non-Unicode, or vice versa, the data will need to be converted in every transaction, which is error prone and can be slow. ✔ When doing character transformation, text strings may grow or shrink substantially. Each UTF-8 code point may be from 1 to 4 bytes, and in some cases a single character in another encoding may correspond to several UTF-8 code points or vice versa. Display ✔ Display all Unicode code points that are supported by the underlying operating system. Modern operating systems all have Unicode support, but their rendering engines are not always correct for all scripts and languages. Provide character rendering in applications only when correct rendering is not available from the target operating system(s). ✔ When developing an app or a service consider the languages supported and make sure operating systems and applications cover those languages.  ✔ Convert A-labels to U-labels before display. For example, the end user should see “example.みんな” rather than “example.xn--q9jyb4c”. (This conversion is an example of UA-ready processing). ✔ Display domain names as U-labels by default. Display A-labels to the user only when it provides a benefit. ! Be aware that mixed-script domain names are possible. ▪ Some Unicode characters may look the same to the human eye, but different to computers; for example, Latin O, Cyrillic O, and Greek omicron O. ▪ Mixed-script strings are common in closely related scripts (e.g., Japanese Kanji, Katakana, Hiragana, and Romaji.) Otherwise mixed scripts may be intended for malicious purposes, such as phishing. Use Unicode Technical Standard #39, Unicode Security Mechanisms,7 to check that the scripts in a Unicode sequence follow good practice. ▪ If the user interface calls the strings to the user’s attention, be sure that it does so in a way that is not prejudicial to users of non-Latin scripts. Learn more about Unicode Security Considerations at:  ✔ Be aware of unassigned and disallowed characters for domain names. ▪ See RFC 5892 Unicode 7 ✔ Use supported Unicode-enabled APIs. ✖ Use standard, well-debugged APIs for: ▪ String format conversions. ▪ Determining which script comprises a string. ▪ Determining if a string contains a mix of scripts. ▪ Unicode normalization/decomposition. See   ✖ Don’t use UTF-7 and limit the use of UTF-32. ▪ UTF-7 is obsolete. ▪ UTF-32 uses four bytes for each code point. Since each code point takes the same amount of space and can be directly indexed in arrays, it’s convenient to use within program code, but may be too bulky for storage in files and databases. ✖ Don’t use UTF-16 except where it is explicitly required (as in certain Windows APIs, and Javascript applications). In UTF-16, 16 bits can only represent characters from 0x0 to 0xFFFF. Values above this range (0x10000 to 0x10FFFF) use pairs of pseudo-characters known as surrogates. If handling of surrogate pairs is not thoroughly tested, it may lead to tricky bugs and potential security holes. ✔ Use UTF-8 in cookies so they can be read correctly by applications. ✔ Use IDNA 2008 Protocol and Tables documents: ▪ RFC 5891 ▪ RFC 5892 ✖ Do not use IDNA 2003 which has been superseded by IDNA 2008. ! Maintain IDNA and Unicode tables that are consistent with regard to versions. For example, unless the application actually executes the classification rules in the Tables document to interpret code points as entered (RFC 5892), its IDNA tables must be derived from the version of Unicode that is supported on the system. The tables do not need to reflect the latest version of Unicode, but they must be consistent. ✔ Validate labels using IDNA 2008 whole-label rules. ▪ In some contexts, further validation may be appropriate; for example, if the application knows what scripts are allowed in the domain names it uses. General ✔ Use authoritative resources to validate domain names. Do not make outdated ad hoc assumptions, such as “all TLDs are 6 characters or shorter.” ✔ Ensure that the product or feature handles numbers correctly. For example, ASCII numerals and Asian ideographic number representations should all be treated as numbers in numeric contexts.  ! Look for mail addresses that may be EAI addresses in unexpected places: ▪ Artist/author/photographer/copyright metadata. ▪ Font metadata. ▪ DNS contact records. ▪ Binary version information. ▪ Support information. ▪ OEM contact information. ▪ Registration, feedback, and other forms. ! Restrict the code points allowed when generating new domain names and email addresses: All products that use email addresses must accept internationalized email addresses, allowing most UTF-8 printing characters in the local part. However, an app or service need not allow all of these characters when a user creates a new IDN or EAI address. Preventing certain IDNs or email addresses from being created in the first place can mitigate some likely security and accessibility concerns. (NOTE: Good practice would still require software to accept such strings if presented.) ! Be aware that Universal Acceptance cannot always be measured through automated test cases alone. For example, testing how an app or protocol handles network resource may not always be possible and sometimes it is best to verify the compliance through functional spec and design review. ! Don’t assume that because a component does not directly call name-resolution APIs or directly use email addresses, it does not affect it. Understand how domain names are obtained by the component—it is not always through user interaction. The following are some examples on how the component can get a domain name: ▪ Group policy. ▪ LDAP query. ▪ Configuration files. ▪ Windows Registry. ▪ Transferred to or from another component or feature. ✔ Perform code reviews to avoid buffer overflow attacks. ▪ In Unicode, strings may expand or shrink when case folded or normalized. ▪ When doing character conversion, text may grow or shrink substantially. Other challenges  Mechanism to detect and convert character sets Some older email applications used local character encodings and did not have a way to detect and convert text to and from UTF-8 as needed. This was especially true for the email headers (TO, CC, BCC, Subject). Managing multiple email addresses as a single user identity When a user has multiple email addresses it may be tricky to manage these addresses as a single user identity. Email programs can direct traffic addressed to such aliases to the same mailbox, but applications may still treat the addresses as different identities. Authoritative Sources for Domain Names: DNS Root Zone and IANA Lists There are two sources for the authoritative list of TLDs. The first source is the DNS root zone itself. It is Domain Name Security Extensions (DNSSEC)-signed, so its contents can be authenticated by a DNSSEC-aware name server, although its contents are fairly hard to parse as a text file. Another source is the text file of TLDs that IANA publishes (one TLD per line in alphabetical order). These files are on https web servers, so it is good practice to check that the site’s Transport Layer Security (TLS) certificate is valid when downloading to be sure you’re getting the right file. You can obtain the list of TLDs from either of the following links: ▪ ▪  (root zone file)  (text TLD file) Email with IDNs and Why It Is Not the Same as EAI Email Address Internationalization (EAI) mail prefers UTF-8 domain names; ASCII coded ALabels are discouraged. Some mail systems have made partial provisions for email addresses that include IDNs rather than provide full EAI support. Because IDNs can be represented as ASCII A-labels, some existing software allows the IDNs in an email address to be represented in ASCII or Unicode. For example, some software will treat these two IDN addresses equivalently for all purposes (sending, receiving, and searching): user@example.みんな = user@example.xn--q9jyb4c However, some software will not treat these addresses as equivalent even though both are valid, because it does not convert an A-label ( “xn--q9jyb4c”) into its U-label equivalent (“み んな”) before comparing. This can result in an unpredictable user experience. The user experience may become especially confusing if some software converts U-labels into Alabels for “compatibility.” As the messages are replied-to or forwarded, the addresses that are visibly different to a user, or which fail to search and sort as expected, may increase. As in the example below, some software may attempt to convert the local part of the email address using Punycode, the algorithm that is used to convert A-labels into U-labels (and vice versa). This sort of conversion is invalid and will create invalid, undeliverable addresses.  Never try to convert the local part of an email address into a different form ✔ 用戶@example.みんな ✖ xn--youq53b@example.xn--q9jyb4c Robust UA-ready software and services should be able to handle and treat all these formats correctly and should be able to handle both UTF-8 local parts and UTF-8 U-labels in addresses, while also accepting A-labels in addresses for backward compatibility. Linkification and Its Challenges Modern software sometimes allows a user to automatically create a hyperlink simply by typing in a string that looks like a web address, email name, or network path. For example, typing “www.icann.org” into an email message may automatically result in a clickable link to  if the application recognizes “www.” as an initial label or “.org” as a TLD. Linkification is the action whereby an application accepts a string and dynamically determines whether it should create a hyperlink to an Internet Location (http:// or  or an email address (mailto:). Linkification, if it happens, should work consistently for all wellformed web addresses, email names, and network paths. Linkification uses algorithms and rules created by software developers to determine whether or not a string should be interpreted as a link. Related to this is how people can identify a string as a domain name. While browsers, email clients, and word processors are obvious places, there are many more applications that make these decisions. Good Practice Recommendations 1. Attempt to linkify based on explicit protocol prefixes (e.g. “ ftp://”, “mailto:”) but only complete the action if the rest of the string is well-formed. Example String Expected Behavior/ Result example.com No linkification because protocol is absent and not inferred.  Create hyperlink because protocol is explicit. http:example.com No linkification because of bad syntax (missing //).  No linkification because “a” is not a TLD.  No linkification because of bad syntax (consecutive dots).  Create hyperlink because protocol is explicit. 2. Attempt to linkify based on implicit protocol prefixes (e.g. “www” infers “  Example String Expected Behavior/ Result www.example.com Create hyperlink because protocol is implied8 label@example.com Create mailto: label@example.com because protocol is implied. 3. The HTML surrounding URLs that contain bidirectional text may include codes that affect the direction in which text is displayed. The linkified version should keep the same display direction. 4. If TLDs are used as a “special token” to determine linkability, then all TLDs must be included. A list of TLDs should be updated on a frequent basis. Unicode—Background and Code Point Attributes The Unicode standard has been evolving since it was first published as Unicode 1.0 in 1991. Each version since has added more characters and code points to handle more languages and scripts. The current version is 12.1. In Unicode, every code point has a set of properties, such as Uppercase_Letter, Decimal_Number, or Nonspacing_Mark. Many characters have a script property such as Latin, Han (Chinese), or Arabic, while others, such as punctuation, do not. As described below, IDNA uses code point attributes to determine which characters are allowed in IDNs. UAX#44, Unicode Character Database, describes the database of code point attributes. UTF8, UTF16, and Other Encoding Methods A Unicode code point can have a numeric value ranging from zero to 0x10FFFF. Since a single byte can hold only values from 0 to 0xFF, some sort of multi-byte encoding is needed to store Unicode code points. The original version of Unicode had fewer than 64K (0xFFFF) code points, so each code point could fit in a 16 bit integer. This led to a two-byte encoding known as UCS or UCS-2. When Unicode expanded past 64K code points, UCS was extended into UTF-169, which uses pairs of otherwise invalid 16-bit code points known as surrogates to represent values greater than 64K. While this works, it has led to debugging problems since surrogates add complexity to any code that counts the number of code points in a string, or that sorts strings into code point order. An additional problem is that some computers such as those made by IBM store the high byte of a 16-bit value first (“big-endian”), and some such as those made by Intel store the low byte first (“little-endian”). As a result, UTF-16 has two storage variants: Note: the actual website might be https-only and require https:// instead of  If this is the case, then the hyperlink may not resolve. 8 See section 3.10 of the Unicode standard for technical details of UTF-8, UTF-16, and UTF-32, at  9  UTF-16BE and UTF-16LE. There are techniques to detect and fix endian problems but they can lead to bugs. At this point, UTF-16 is primarily used in existing applications with Microsoft Windows APIs, and the Java and Javascript languages. An alternative encoding is UTF-8, which encodes each code point as a variable length string of one to four bytes. UTF-8 has several advantages over UTF-16, including that the ASCII subset of Unicode is encoded as a single byte so any ASCII string is automatically a UTF-8 string. UTF-8 is usually more compact than its UTF-16 equivalent, and is easier to sort because UTF-8 strings sorted in byte order are automatically in code point order. IDNA and EAI all require UTF-8 coding. UTF-32 is a simple format that stores each code point in a 32-bit integer. It is convenient for internal processing in programs since the code points in an array of UTF-32 can be indexed directly, but it is rarely used in storage because of its bulk. IDNA – A Brief History and Current State Internationalized Domain Names in Applications (IDNA) was first defined by the IETF in 2003 as what is now known as IDNA200310. It included an algorithm to map Unicode code points into a standard form in domain name labels known as Nameprep, and an algorithm to encode Unicode code point labels in ASCII known as Punycode. Nameprep includes transformations such as mapping upper to lower case. After some experience with IDNA, the IETF developed and published a revised spec known as IDNA2008 in 201011. IDNA2008 created the terms U-label and A-label and removed the Nameprep step, advising that applications should do a mapping appropriate for the locale and application environment. IDNA2008 was updated for Unicode 6.0 by RFC 6452 in 2011 and continues to be reviewed by the IETF. In practice, too many implementations are still using IDNA2003. A few libraries do use tables (like the ones included in IDNA2003) created for IDNA2008. No locale mappings exist for IDNA2008 except the standard case folding and normalization rules included in the Unicode Standard. One exception is that there are a few mappings from UTS#46, Unicode IDNA Compatibility Processing. This specifies whether a few common characters that are mapped in IDNA2003 but allowed as characters in IDNA2008 should be accepted or mapped. It is important for applications to treat these characters according to IDNA2008 and not IDNA2003, and that if UTS#46 is in use, it is used in a way that is compatible with IDNA2008. Use Cases for Testing Software that is intended to handle IDNs and EAI mail addresses should be tested with a wide range of domain names and addresses. See UASG 004, Use Cases for UA Readiness Evaluation, for a set of test cases. 10 11 The definition is in RFCs 3490, 3491, and 3492. The definition is in RFCs 5890, 5891, 5892, 5893, 5894, and 5895.  Upgrading Software for EAI EAI conformance requires upgrades to mail servers, submission and delivery software, mail user agents and web mail, and any application that handles email addresses and sends mail. For a detailed overview of EAI, its issues, and how to implement it, see UASG 012, Email Address Internationalization (EAI): A Technical Overview. Advanced Topics Complex Scripts The details of complex scripts may be of limited interest to those who are not developers creating their own string parsing or display libraries. Nevertheless, a summary is included here to ensure that all readers have sufficient awareness to recognize code bugs related to these scripts when encountered in user experiences. For formatted HTML text in web pages and email, the HTML standards have elaborate features for handling and displaying complex and bidirectional text, which developers should understand and use to render text. See the WHATWG HTML standard section on rendering12, and the corresponding section of the W3C HTML standard13. Right-to-Left Languages and Unicode Conformance Some scripts, such as Latin and Devanagari, display characters from left to right when text is presented in horizontal lines. Other scripts, such as Arabic or Hebrew, display characters from right to left. The text can also be bidirectional when a right-to-left script uses digits that are written from left to right or when it uses embedded words from English or other languages that are written using left-to-right scripts. Challenges and ambiguities can occur when the horizontal direction of the text is not uniform. To solve this issue, there is an algorithm to determine the directionality for bidirectional Unicode text. There is a set of rules that should be applied by the application to produce the correct order at the time of display which are described by the Unicode Bidirectional Algorithm. We generally refer to this as the “Bidi algorithm”. The Bidi Algorithm The Bidi algorithm describes how software should process text that contains both left-to-right (LTR) and right-to-left (RTL) sequences of characters. The base direction14 assigned to the Available at  Available at  14 In HTML the base direction is either inherited from the default direction of the document, which is left-to-right, or explicitly set by the nearest parent element that uses the “dir” direction attribute. 12 13  phrase will determine the order in which text is displayed. This can be either left-to-right or right-to-left and defines the order in which sequences of characters are displayed. In this document, the base direction is left to right so all sequences of characters are displayed with the first sequence to the left of the second sequence. To know if a sequence is left-to-right or right-to-left, each character in Unicode has an associated directional property. Most letters are strongly typed (strong characters) as LTR (left-to-right) or RTL (right-to-left) depending on the script of which they are a part. A sequence of strongly typed RTL characters will be displayed from right to left. This is independent of the surrounding base direction. For example: (LTR) example - ‫( مثال‬RTL). Text with different directionality can be mixed in line. In such cases, the Bidi algorithm produces a separate directional run out of each sequence of contiguous characters with the same directionality. Spaces and most punctuation are not strongly typed as either LTR or RTL in Unicode because they may be used in either type of script. They are therefore classified as neutral or weak characters. Weak characters are those which are generally used in one direction, but in some contexts may be used in the other. Examples of this type of character include: ▪ ▪ ▪ ▪ European digits. Eastern Arabic-Indic digits. Arithmetic and currency symbols. Punctuation symbols that are common to many scripts, such as the colon, comma, full-stop, and the no-break space. The directionality of neutral characters is indeterminate without context. Some examples include: ▪ Tabs. ▪ Paragraph separators. ▪ Most other whitespace characters. When a neutral character is between two strongly typed characters that have the same directional type, it will also assume that directionality. For example, a neutral character between two RTL characters will be treated as an RTL character itself, and will have the effect of extending the directional run: ▪ ‫مثال‬.‫نطاق‬ Even if there are several neutral characters between the two strongly typed characters, they will all be treated in the same way. When a space or punctuation falls between two strongly typed characters that have different directionality, the neutral character(s) will be treated as if it has the same directionality as the prevailing base direction. For example: ▪ example. ‫مثال‬  Remember that this document has left to right as its base sequence so example is the second level domain and ‫ مثال‬the TLD. Unless a directional override is present, numbers are always encoded and entered highorder digit first, and the numerals rendered LTR. The weak directionality applies only to the placement of the number in its entirety. The full details of the Bidi algorithm are described in Unicode Technical Report #9. The Bidi Rule for Domain Names A Bidi domain name is one that contains at least one RTL label. The Bidi rule for domain names, specified in RFC 589315, limits the code points in names so that there are no two names that are different sequences of code points but display the same due to bidirectional display rules. Joiners Some languages use alphabetic scripts in which single phonemes are written using two characters called a digraph. In other words, a digraph is a group of two successive letters that represent a single sound (or phoneme). Examples of digraphs in English ch (as in church) ph (as in phony) th (then) th (think) sh (shoe) gh (rough) Some digraphs are fully joined as ligatures. In writing and typography, a ligature occurs where two or more graphemes or letters are joined as a single glyph. An example is the ampersand character (&), which evolved from the adjoined Latin letters e and t (“et” means “and”). In typeset English, fi and ffi often are displayed as ligatures. If ligatures and digraphs have the same interpretation in all languages that use a given script, Unicode normalization generally resolves the differences and makes them match. When they have different interpretations, matching must use alternative methods (likely chosen at the registry level) or users must be educated to understand that matching will not occur. An example of different interpretation can be found in Section 4.3 of RFC 5894 16. The Unicode Consortium lists two main strategies to determine the joining behavior of a particular character after applying the Bidi algorithm to deal with zero width joiner characters known as ZWJ and ZWNJ. (To learn more about these joiners see  Right-to-Left Scripts for Internationalized Domain Names for Applications (IDNA), RFC 5893,  16 Internationalized Domain Names for Applications (IDNA): Background, Explanation, and Rationale, RFC 5894,  15  ▪ ▪ When shaping, an implementation can refer back to the original backing store to see if there were adjacent ZWNJ or ZWJ characters. Alternatively, the implementation can replace ZWJ and ZWNJ by an out-of-band character property associated with those adjacent characters, so that the information does not interfere with the Bidi algorithm and the information is preserved across rearrangement of those characters. Once the Bidi algorithm has been applied, that out-of-band information can then be used for proper shaping. Domain name registries and any other entity that allows the creation of domain names (e.g. applications that create third- and lower-level labels) must follow the Bidi Rule for Domain Names to ensure that names will display consistently and to prevent confusing names that can be used for homograph attacks. To learn more about joiners, see Section 4.3 of RFC 5894. Homoglyphs and Similar Characters Homoglyphs are characters that, due to similarities in size and shape, appear identical or confusingly similar. They frequently occur when mixing Latin, Cyrillic, and Greek scripts. For example, Latin “o” (code U+006f), Cyrillic small letter “о” (code U+043e), and Greek small letter omicron “ο” (code U+03bf.) In some cases, there are homoglyphs in a single script, such as the small Croatian letter “ǉ” (code U+01c9) and the two letters “lj” (code U+006c U+006a). See the table at  for more examples. To prevent domain names with homoglyphs, registries should use Label Generation Rules (LGRs) that limit the code points in a label to a set from a single script or compatible scripts. Each registry should have LGRs for each script in which it accepts registrations17. To learn more about Unicode security mechanisms for confusable detection, see: ▪  To learn more about confusingly similar characters and good practice, see: ▪ ▪ M3AAWG Unicode Abuse Overview and Tutorial  M3AAWG Best Practices for Unicode Abuse Prevention  Normalization, Case Folding, and String Preparation Unicode Normalization helps to determine whether any two Unicode strings are equivalent to each other and provides standard forms to use to process and store strings. Some characters can be represented in Unicode by several code sequences. This is called Unicode equivalence. Unicode provides two types of equivalences: IANA has a collection of registry LGRs in its Repository of IDN Practices at  17  ▪ ▪ Canonical Compatibility Sequences representing the same visual character are called canonically equivalent. These sequences have the same appearance and meaning when printed or displayed. For example: U+006E (Latin lowercase “n”) followed by U+0303 (the combining tilde “◌̃”) =ñ U+00F1 (lowercase letter “ñ” of the Spanish alphabet) =ñ Unicode defines NFC (Normalization Form C) as Canonical Decomposition, followed by Canonical Composition. This reduces text to a minimal number of code points while not changing its appearance. It should be noted that in this example, three characters above are valid to be used according to IDNA2008. Compatibility equivalents are sequences which can appear different, but in some contexts the same meaning. It is a weaker type of equivalence between characters or sequences of characters. For example: U+FB00 (the typographic ligature “ﬀ”) = ff U+0066 U+0066 (two Latin “f” letters) = ff In the example above, the code point U+FB00 is defined to be compatible, but not canonically equivalent to the sequence U+0066 U+0066. Sequences that are canonically equivalent are also compatible, but the opposite is not always true. It should be noted that the code point U+FB00 is not valid according to IDNA2008. Unicode defines NFKC (Normalization Form KC) a Compatibility Decomposition, followed by Canonical Composition. This reduces text to a standard set code points and may change its appearance. For example, NKFC turns the ligature “ﬀ” into the two letters “f f” and the ante meridian symbol ㏂ (U+33C2) into the four characters “a.m.” (U+0061 U+002E U+006D U+002E.) To avoid interoperability problems arising from the use of canonically equivalent, yet different, character sequences, the W3C recommends using NFC for all text. To see a list of all characters that may change in any of the Normalization Forms, see:  Some other points to note: ▪ ▪ ▪ The characters in IDN labels must be in NFC form. When two applications share Unicode data, but normalize them differently, errors and data loss can occur. The Unicode consortium asserts that Normalization Forms must remain stable over time. In other words, a string must remain normalized under all future versions of Unicode for backward compatibility.  ▪ As pointed out earlier, be conservative when looking at what code points to allow in a domain name. Tips for software developers ✖ Don’t attempt to normalize by converting to uppercase or ignoring non-spacing characters, because this makes sorting, data copying import and export, and data retrieval by client applications difficult and may result in data loss or corruption. ✖ Never allow code points in domain names which are not allowed according to IDNA2008. To learn more about Unicode normalization, see: ▪  ▪  Case Folding and Mapping Case folding and mapping is the process of turning all of the characters in a string into the same case, usually lower case. Mapping upper case [A-Z] to lower case [a-z] works for ASCII-only text documents, but is far more complex in languages that use additional characters. Case mapping can be context-dependent, with the mapped character depending on the context in which it occurs, e.g., various forms of the Greek sigma. It can also be locale-dependent, with the mapped character depending on the locale in which the text is interpreted, e.g., Turkish dotted and undotted upper and lower case I. Case folding is localeindependent, for strings that will be interpreted by software, while case mapping is localedependent and is intended for text to be read by people. Finally, mapping to upper case and mapping to lower case are not inverse functions. For IDNs, IDNA2008 allows applications to use any appropriate case mapping because the mapping takes place before the validation of code points. In practice, locale-specific identifier mappings do not exist and everyone uses the mappings from Unicode’s UTS#4618. Tips for software developers 18 ✔ Consider the desired goal before attempting case mapping: is it a generic map for labels, a string in a known language, or something else? ✔ Perform Unicode Normalization before case folding. UTS#46, Unicode IDNA Compatibility Processing,   Glossary and Other Resources Glossary A-label The ASCII-compatible encoded (ACE) representation of a label in an Internationalized Domain Name, used internally within the DNS protocol. A-labels always begin with the ACE prefix “xn--”. An A-label can be converted to a U-label and back without loss of information. ACE prefix ASCII Compatible Encoding Prefix “xn--”. ASCII American Standard Code for Information Interchange. ASCII includes unaccented Latin characters and the EuropeanArabic digits. ASCII is a subset of Unicode: every ASCII character is also a Unicode character. API An Application Programming Interface (API) is a set of routines, protocols, and tools for building software and applications. An API may be for a web based system, operating system, or database system, and it provides facilities to develop applications for that system using a given programming language. Codespace Range that defines the lower and upper bounds for an encoding. Code point A code point is a numerical value in a code space. Code points are used to distinguish a numerical value from its encoding as a sequence of bits, and to distinguish an abstract character from a particular graphical representation of it (glyph). DNS Root Zone The root zone is the central directory for the DNS, which is a key component in looking things up in DNS; for example, translating host names into IP addresses. EAI Email Address Internationalization allows UTF-8 characters in an email address—the domain name, the local part, or both.  IANA ICANN Internet Assigned Numbers Authority. Its functions include: ▪ Management of the DNS Root, the .int and .arpa domains, and an IDN practices resource. ▪ Coordination of the global pool of IP and AS numbers, primarily providing them to Regional Internet Registries (RIRs). ▪ Internet Protocols’ numbering systems are managed in conjunction with standards bodies. ICANN's mission is to help ensure a stable, secure, and unified global Internet. To reach another person on the Internet, you need to type an address – a name or a number – into your computer or other device. That address must be unique so computers know where to find each other. ICANN helps coordinate and support these unique identifiers across the world. ICANN was formed in 1998 as a not-for-profit publicbenefit corporation with a community of participants from all over the world. IDN Internationalized Domain Name. IDNs are domain names that include UTF-8 characters beyond the twenty-six letters of the basic Latin alphabet “a-z”, the numbers 0-9, and the hyphen “-“. IDNA Internationalized Domain Names in Applications. IDN ccTLD Country code top-level domain that includes characters beyond the twenty-six letters of the basic Latin alphabet “a-z”. Examples: ▪ .рф (Russia) ▪ ‫صر‬. (Egypt) ▪ ‫السعودية‬. (Saudi Arabia) IETF The Internet Engineering Task Force (IETF) is a large open international community of network designers, operators, vendors, and researchers concerned with the evolution of the Internet architecture and the smooth operation of the Internet. It is open to any interested individual. The IETF develops Internet Standards, in particular, the standards related to the Internet Protocol Suite (TCP/IP) and the protocols used for the web like HTTP and TLS. Language The method of human communication, either spoken or written, consisting of the use of words in a structured and conventional way. Punycode An algorithm that represents UTF-8 in the limited character subset of ASCII supported by the Domain Name System (DNS). Punycode is used in A- labels in the Internationalized Domain Names in Applications (IDNA) framework.  Registrar An organization where domain names are registered by users. The registrar keeps records of the contact information and submits the technical information to a central directory known as the “registry”. Registry The authoritative, master database of all domain names registered in each top-level domain (TLD). RFC A Request for Comments (RFC) is a formal document from the Internet Engineering Task Force (IETF) that is the result of committee drafting and subsequent review by interested parties. Some (but not all) RFCs document approved Internet standards. Script The collection of letters or characters used in writing, representing the sounds of a language. Second-level domain name In the Domain Name System (DNS) hierarchy, a second-level domain (SLD or 2LD) is a domain that is directly below a toplevel domain (TLD). For example, in example.com, example is the second-level domain of the .com TLD. U-label A U-label is an IDNA-valid string of Unicode characters including at least one non-ASCII character. It can be converted to an A-label and back without loss of information. UA-ready software or UA-readiness Software that has the ability to accept, store, process, validate, and display all top-level domains, IDNs, and email addresses equally. Unicode A universal character encoding standard. It defines the way individual characters are represented in text files, web pages, and other types of documents. Unicode was designed to support characters from all languages around the world. It can support roughly 1,000,000 characters. See:  UTF Unicode Transformation Format. It is a way of representing Unicode code points as a stream of bytes. UTF-8 is the preferred UTF for handling IDN and EAI. UTF-8 converts Unicode to 8-bit bytes. M3AAWG The Messaging, Malware and Mobile Anti-Abuse Working Group (M3AAWG) is where the industry comes together to work against botnets, malware, spam, viruses, DoS attacks, and other online exploitation. See:  W3C The World Wide Web Consortium (W3C) is an international community where member organizations, a full-time staff, and the public work together to develop web standards like HTML. See:   WHATWG The Web Hypertext Application Technology Working Group (WHATWG) is a community of people interested in evolving the web through standards and tests. The WHATWG was founded by individuals of Apple, the Mozilla Foundation, and Opera Software in 2004, after a W3C workshop. See  ZWJ Zero-Width Joiner is non-printing character used in the computerized typesetting of some scripts, including Arabic and all of the Indic scripts. When placed between two characters that would otherwise not be connected, a ZWJ causes them to be printed in their connected form. ZWNJ Zero-Width Non-Joiner is a non-printing character used in the computerization of writing systems that make use of ligatures. For some languages and scripts, many of the letters of the alphabet naturally connect with the following letter when written in a word, forming a ligature. In order to correctly display certain prefixes, suffixes, and compound words, however, the ZWNJ is used to override this natural behavior of joining letters and prevent them from joining the following letter (but without adding a space between the two). For a complete ICANN glossary, go to:  RFCs and Key Standards IDN RFCs RFC 3492 Punycode: A Bootstring encoding of Unicode for Internationalized Domain Names in Applications (IDNA) RFC 3492 describes Punycode as: "a simple and efficient transfer encoding syntax designed for use with Internationalized Domain Names in Applications (IDNA)" Punycode transforms uniquely and reversibly a Unicode string into an ASCII string. This RFC defines a general algorithm called Bootstring. This algorithm allows a string of basic code points to uniquely represent any string of code points drawn from a larger set.   RFC 5890 Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework This RFC describes the usage context and protocol for a revision of Internationalized Domain Names for Applications (IDNA).  RFC 5891 Internationalized Domain Names in Applications (IDNA) Protocol This RFC specifies the protocol mechanism, called Internationalized Domain Names in Applications (IDNA), for registering and looking up IDNs in a way that does not require changes to the DNS itself.  RFC 5892 The Unicode Points and Internationalized Domain Names for Applications (IDNA) The RFC 5892 specifies rules for deciding whether a code point, considered in isolation or in context, is a candidate for inclusion in an Internationalized Domain Name (IDN).  RFC 5893 Right-to-left scripts for Internationalized Domain Names for Applications (IDNA) This RFC provides a new Bidi rule for Internationalized Domain Names for Applications (IDNA) labels, for the use of right-to-left scripts in Internationalized Domain Names.  RFC 5894 Internationalized Domain Names for Applications (IDNA): Background, Explanation and Rationale This informational document provides an overview of a revised system to deal with newer versions of Unicode and provides explanatory material for its components.  RFC 5895 Mapping Characters for Internationalized Domain Names in Applications (IDNA) 2008 This RFC describes the actions that can be taken by an implementation between receiving user input and passing permitted code points to the new IDNA protocol (2008). It describes an operation that is to be applied to user input in order to prepare that user input for use in an “on the network” protocol. It also includes a general implementation procedure for mapping.   EAI RFCs RFC 6530 Overview and Framework for Internationalized Email This standard introduces a series of specifications that define mechanisms and protocol extensions needed to fully support internationalized email addresses. This document describes how the various elements of email internationalization fit together and the relationships among the primary specifications associated with message transport, header formats, and handling.  RFC 6531 SMTP Extension for Internationalized Email The document defines a Simple Mail Transfer Protocol extension so servers can advertise the ability to accept and process internationalized email addresses and internationalized email headers.  RFC 6532 Internationalized Email Headers This document specifies an enhancement to the Internet Message Format and to MIME that allows use of Unicode in mail addresses and most header field content. This document specifies an enhancement to the Internet Message Format (RFC 5322) and to MIME that permits the direct use of UTF-8, rather than only ASCII in header field values, including mail addresses. A new media type, message/global, is defined for messages that use this extended format. This specification also lifts the MIME restriction on having non-identity content-transferencodings on any subtype of the message top-level type so that message/global parts can be safely transmitted across existing mail infrastructure.  RFC 6533 Internationalized Delivery Status and Disposition Notifications This specification adds a new address type for international email addresses so an original recipient address with non-ASCII characters can be correctly preserved even after downgrading. This also provides updated content return media types for delivery status notifications and message disposition notifications to support use of the new address type.   RFC 8398 Internationalized Email Addresses in X.509 Certificates This document defines a new name form for inclusion in the otherName field of an X.509 Subject Alternative Name and Issuer Alternative Name extension that allows a certificate subject to be associated with an internationalized email address.  RFC 8399 Internationalization Updates to RFC 5290 The updates to RFC 5280 described in this document provide alignment with the 2008 specification for Internationalized Domain Names (IDNs) and add support for internationalized email addresses in X.509 certificates.  Key Standards ISO 10646 (Unicode) To provide a common technical basis for the processing of electronic information in various languages, the International Organization for Standardization (ISO) has developed an international coding standard called ISO 10646. The ISO 10646 provides a unified standard for the coding of characters in all major languages in the world, including traditional and simplified Chinese characters. This large character set is called the Universal Character Set (UCS). The same set of characters is defined by the Unicode standard, which further defines additional character properties and other application details of great interest to implementers. Unicode is a character coding system designed by the Unicode Consortium to support the interchange, processing and display of the written texts of all major languages in the world. ISO 10646 and Unicode define several encoding forms of their common repertoire: UTF-8, UCS-2, UTF-16, UCS-4 and UTF-32.  ail_ics.htm?csnumber=63182 GB18030 (China) GB 18030-2000 is a Chinese government standard that specifies an extended code page for use in the Chinese market in addition to UTF-8. The internal processing code for the character repertoire can and should be Unicode; however, the standard stipulates that software providers must guarantee a successful round-trip between GB18030 and the internal processing code. All products currently sold or to be sold in China must plan the code page migration to support GB18030  without exception. GB18030 is a “mandatory standard” and the Chinese government regulates the certification process to reinforce GB18030 deployment.  Online Resources APIs Windows Application Programming Interfaces (APIs)  28v=vs.85%29.aspx SharePoint APIs  Public Suffix List  ICANN Authoritative TLD list  Android APIs  MAC IOS APIs  .Net Framework  Unicode security Unicode security considerations  Unicode security mechanisms  Unicode character groupings Unicode code planes  pp. 44-54 Overview of GB18030  Authoritative mapping table between BG18030-2000 and Unicode  Unicode normalization   Unicode exploits Section 3.1, “UTF-8 Exploits” in Unicode Technical Report #36  M3AAWG Best Practices for Unicode Abuse Prevention  M3AAWG Unicode Abuse Overview and Tutorial  See also:  Miscellaneous URIs  The Domain Name System: A Non-Technical Explanation—Why Universal Resolvability Is Important  ICANN glossary  Need more information? The Universal Acceptance Steering Group (UASG) and community are available to provide advice to software developers and implementers. 👍 Contact us to share your ideas and suggestions on the topic at info@uasg.tech. 👍 Join the Universal Acceptance discussion list at  👍 To learn more about the effort, visit   POP3 support for EAI 19 IMAP support for EAI 19 EAI message headers 20 Headers with addresses 20 Header fields that users see 20 Header fields with contents for machines 20 Received headers 21 MIME headers 22 Handling and reporting delivery failure 22 Backward compatibility 24 EAI and legacy recipients 24 Whether to downgrade 21 Where mail can be downgraded 25 General downgrade techniques 25 Headers and bodies 25 Downgrading headers with addresses 25 Downgrading other headers that users see 26 Downgrading headers that users do not see 26 Downgrading in POP and IMAP 27 Downgrade notes 28 Out-of-office, read receipts, and other autoresponders Mail authentication and spam filters 28 28 SPF authentication 28 DKIM authentication 29 DMARC authentication 30 Spam filtering 30 Appendix A: Handling message header fields 30 Appendix B: Summary of steps necessary to move to EAI 35 Changes to MTAs 35 Changes to MSAs 35 Changes to MUAs 35 IMAP Servers 35 POP Servers 36 UASG012: Email Address Internationalization (EAI): A Technical Overview  Appendix C: How does SMTP work? Adding UTF-8 features to the SMTP example Appendix D: Relevant RFCs 36 37 37 Important mail RFCs 38 For SMTP: 38 For mail message formats: 38 For POP and IMAP: 38 For IDNs: 38 For EAI mail: 39 For PRECIS and string mapping: 39 For SASL (logging in and authenticating for POP, IMAP, and submission): 39 For URLs and URIs: 39 For message authentication: 39 For input and display of RTL and mixed direction text: 40 Appendix E: Other sources of advice 40 Glossary UASG012: Email Address Internationalization (EAI): A Technical Overview  This introduction to Email Address Internationalization (EAI) is intended for technically capable email application developers and systems administrators who want to add EAI support to mail software. For a high-level view of EAI, see UASG014: Quick Guide to EAI. For background information on mail and related technologies, see Other Sources of Advice at the end of this document. Why do we need EAI? When modern Internet mail was defined in the 1980s, the net’s working language was English and all mail was written using the ASCII character set, which only has unaccented upper and lower case Roman characters. But nearly every other written language requires characters outside the ASCII set. On the modern Internet, mail users live in every country in the world and write in a vast array of languages, and email has been slowly evolving to handle all of them. Unicode can represent all those characters. EAI allows Unicode characters, specifically Unicode characters encoded as UTF-8,1 in email addresses. Standards and interoperation The Internet works because the software on the computers connected to it is designed to interoperate. The software is written so that, for example, any computer can send mail to any other computer running mail software. The software all implements standards that describe how to do all of the things the Internet does, from the lowest level packet switching to the codes for formatted HTML text pages and file attachments. For software to interoperate, everyone has to implement the standards in the same way. In this document, we emphasize how to do that, and how to avoid incompatibilities that could prevent interoperating. In particular, even though there are often changes that might seem “better,” if they don’t match the standards, they won’t interoperate with other systems, which is of course not better at all. Parts of the mail ecosystem The path that an email message takes from the sender to the recipient can be rather complex. To make it easier to understand, the IETF mail community has adopted a mail architecture that uses standard names for the various parts of the mail system and the connections among them. The architecture is described in detail in RFC 5598, Internet Mail Architecture. Here we briefly look at the common parts of the architecture and how they fit together as a message travels from author to recipient. 1 UTF-8 is a standard way of storing Unicode code points (characters and modifiers) in 8-bit bytes. For historic reasons, some software uses the name UTF8 without the hyphen. UASG012: Email Address Internationalization (EAI): A Technical Overview  The Mail Software Ecosystem The Internet mail architecture has agreed-on names for the software that handles mail, mostly referred to by three- or four-letter abbreviations. Mail User Agent (MUA) Human mail users read and send mail with a Mail User Agent (MUA), the only program in the mail ecosystem with which users directly interact. Popular MUAs include Outlook, Apple Mail, and the mail programs that people use on smartphones. The user composes the message, perhaps using formatting tools, optionally attaches other media, and then sends the message off using the SUBMIT protocol. For incoming mail, the MUA retrieves mail from mail server(s) using POP or IMAP and displays it to the user. In both cases, the format of the message that the user sees usually differs from the form in which it is submitted or received. Some parts of the message are reformatted, e.g., the Date: header information is often shown in the user’s local format and time zone. Message contents are often decoded and displayed, e.g., a JPEG attachment will be displayed as an image. MUAs usually let the user use address books, where the user can store email address(es) and other information about frequent correspondents. In some cases, the address book is stored on the user’s computer, while other address books can be shared and accessed over the network. Address book entries can be quite complex, with multiple email addresses and other contact information for each correspondent. Webmail Webmail creates a mail client using a combination of the user’s web browser and web servers that the browser connects to. In some versions, the web server uses standard mail protocols to send mail to and retrieve mail from separate mail servers. In others, the web UASG012: Email Address Internationalization (EAI): A Technical Overview  server performs the functions of the MUA or other parts of the mail system. In either case, the webmail provides features similar to those that a separate MUA would perform. Mail Submission Agent (MSA) Once users have created an email message, they tell the MUA to submit it for delivery. The MUA connects to the Mail Submission Agent (MSA). Then the MUA authenticates the message with a password (or implicitly authenticates it with an IP address), and sends the envelope and the message. As the MSA receives the message, it checks for and fixes minor errors in the message format such as a missing Date: or Message-ID: header. Depending on local policy it may force the From: header to match the authenticated user. Many MSAs also add cryptographic authentication signatures at this stage. (See the discussion of DKIM below.) Once the message is prepared, the MSA sends it to the Mail Transmission Agent (MTA). Depending on the design of the mail system, the MSA and MTA may be separate programs, or merely different functions in the same program. The protocol between the MUA and MSA is similar to SMTP (Simple Mail Transport Protocol), which is used between MTAs, but has some significant differences. It’s sometimes called SUBMIT to distinguish it from SMTP. Mail Transmission Agent (MTA) A Mail Transmission Agent (MTA) is what is most often meant by the phrase “mail server.” It receives a completed message from an MSA, and then, for each recipient of the message, determines how and where to deliver the message. In general, for each recipient address, the MTA first finds the domain in the address to see if it’s one that the MTA handles locally. If not, it does a DNS lookup for MX (mail exchanger) records to find the host computers that do handle it, makes an SMTP connection to one of those computers, and sends the message. In the simplest mail systems, the host listed in the MX handles mail delivery itself, while in more complex systems a message may be passed several times from one computer to the next. The SMTP transaction is a sequence of commands from the sending system and responses from the recipient system. The first command and response sets up the connection and lists the SMTP extensions that the recipient system supports, such as the SMTPUTF8 extension that enables EAI mail. Subsequent commands send the envelope information (the return address and recipient addresses) and then send the message itself. For more details on SMTP, see Appendix C: How does SMTP Work?. Mail Delivery Agent (MDA) Once a message has made its way through the recipient’s MTA, it is sent to the recipient’s Mail Delivery Agent (MDA) for delivery. In the simplest case, the MDA simply stores the message into a file for later pickup, but in most cases, there is some delivery-time processing. The IETF has defined a language called SIEVE that enables mail users to write scripts that specify delivery-time processing procedures like sorting mail into separate mailboxes or redirecting mail to other addresses. There are many other delivery programs, such as the UASG012: Email Address Internationalization (EAI): A Technical Overview  widely used procmail. Most Unix and Linux systems allow users to specify arbitrary programs to handle incoming mail. Webmail systems provide various sorts of delivery-time processing. Most enable users to sort mail based on text found in the message (e.g., if the subject includes “pickle-list”, it is saved to the pickle-list folder) while others group mail into categories such as Updates or Forums. Mail storage Originally, an email mailbox was analogous to a physical mailbox, a place to store incoming mail messages temporarily until they were picked up and processed. As computer storage has gotten faster and cheaper, mailboxes have grown to the point where it is now common to store many years of mail. Mail systems generally have multiple folders for each mailbox, with each folder named hierarchically, as disk files are. Messages can be flagged as “unread,” “read,” “important,” or “answered.” Mail programs generally provide ways to organize mail, and to search through messages in various ways, looking for keywords or addresses, or limiting the search by date range. Mail systems use many underlying storage schemes. In the simplest, all of the mail in a mailbox is stored in a single file. Others store each message in a separate file. Mail may also be stored in a database, perhaps with header and body information handled differently. Regardless of the storage scheme, MUAs see the mail as a list of messages in each folder. POP/IMAP mail pickup On early mail systems, users stored their email and ran their mail programs on the same computer, and the mail program read the mail directly from local files. These days, users invariably read their mail on a different computer, using POP and IMAP to retrieve it. POP (Post Office Protocol), the older and simpler protocol, lets the MUA retrieve mail from the mail server and then optionally delete it from the server. The MUA then manages the mail on the user’s own computer. IMAP (Internet Message Access Protocol) lets the user’s mail program manage mailboxes on the server, copying mail to and from the server as desired. Since the mail generally stays on the server, IMAP makes it possible to have mail programs on different computers, such as laptops and phones, show the same view of the mail. Since the mail program doesn’t have to download all the mail, vast amounts of mail can be stored while running mail programs on small computers such as tablets and phones. Another important difference between POP and IMAP is that POP can only see the main inbox for a mail account, while IMAP can manage all of an account’s folders. The expectation was that POP users would copy all the mail to their own computer and manage it there. POP and IMAP both require that a user authenticate before picking up mail, with a username and password. In most cases the POP/IMAP user name is the user’s email address. Mail message formats The basic Internet message format was initially defined by RFC 724 in 1977 and has changed very little over the subsequent 40 years as the specification has been updated UASG012: Email Address Internationalization (EAI): A Technical Overview  several times, most recently by RFC 5822. That format has proven to be flexible enough to support the changing needs of mail users over the years. Each legacy message, i.e., a pre-EAI message, is a sequence of lines of ASCII text ending with the ASCII Carriage Return and Line Feed (CR and LF) characters. The first part of the message, usually called the header, is a series of structured header fields followed by a blank line and ending with an unstructured message body. Each header field starts with a header name such as From: or Subject: and a colon, followed by the contents of the header. Some header field contents are free-format, such as the Subject: header, while others are entirely fixed-format, such as the Date: and Message-ID: headers, while others are a combination of fixed- and free-format, such as the To:, From: and Cc: headers, which combine fixed-format addresses with free-format comment text. Messages are invariably accompanied by metadata, information related to the message but not part of it. The envelope, described in the next section, is an important part of the metadata. Other parts of the metadata may include the date a message was received, whether the recipient has read it, and whether the recipient has marked it as important or as junk. Messages and Envelopes Email messages in transit, from submission to delivery, are accompanied by an envelope. The envelope contains the return address, to which errors should be reported (often called the “bounce address”), the recipient addresses, to which the message should be delivered, and sometimes other information about the delivery process. The envelope information is sent along with—but separately from—the message. When a message is transmitted via SMTP (described in more detail below), one SMTP command sends the return address, additional SMTP commands send each recipient address, then another SMTP command sends the message. UASG012: Email Address Internationalization (EAI): A Technical Overview  When a message starts out, the return address in the envelope usually matches the From: address in the message, and the recipient addresses in the envelope match the To:, Cc:, and Bcc: addresses. But there is no requirement that the envelope addresses match the ones in the message, and there are many common situations where they don’t. For example, if a message is sent to two addresses, Alice and Bob, which are on different mail systems, the copy sent to Alice will only have recipient address Alice, and the copy sent to Bob will only have recipient address Bob. When mail is sent to mail discussion lists, the To: line address is usually the address of the list, but the list software will re-mail the message to all of the list’s subscribers, which means that all of those subscribers will be in the message’s envelope recipients. In addition to addresses, the envelope can include other parameters, such as the size of the message or the identity of the sender of a newly submitted message. As we will see below, in EAI mail, the envelope indicates whether a message is an EAI message or a legacy message. Mail addresses Each legacy email address is of the form local-part@domainname. The local-part is arbitrary ASCII text, and the domain name is a DNS hostname. A legacy hostname is a sequence of labels separated by dots. Each label starts and ends with an ASCII letter or digit and consist of only ASCII letters, digits and hyphens, known as the LDH rule. In principle, legacy local-parts can contain any printable ASCII characters, including spaces and punctuation. In practice names with exotic punctuation are hard to to type and often don’t work well when entered into web forms. In mail headers, addresses are usually enclosed in angle brackets to distinguish them from comment text, e.g.: To: Jim Smith <james@example.com>, Mary Jones <mzjones@example.net> An obsolete but still valid syntax puts the comments in parentheses, e.g. To: james@example.com (Jim Smith), mzjones@example.net (Mary Jones) Internationalized Domain Names Just as Internet users want to use their own scripts in the body of their emails, they also want to use their own scripts in the domain names. Although the Domain Name System (DNS) internally uses eight-bit bytes and could, in principle, have used literal UTF-8 names, a vast amount of DNS support software can only handle ASCII. In addition, Unicode often allows several different ways to produce the same character, e.g., writing an accented “é” UASG012: Email Address Internationalization (EAI): A Technical Overview  either with two code points, a plain “e” and a separate accent character “´", or with a single, precomposed code point for the accented letter. DNS lookups only do exact matches, so if a name were stored in one form but looked up in another, the lookup would fail. The DNS community has addressed this problem with a design known as Internationalized Domain Names in Applications (IDNA.) It uses several techniques to make UTF-8 names work reasonably well. EAI uses the most recent version of IDNA, IDNA2008. Normalization The first is normalization, using a consistent representation of characters that can be represented in UTF-8 in multiple ways, e.g., a single “é” code point or an “e” and an accent “´". The Unicode consortium has defined several normalization forms. IDNs use Normalization Form C (NFC), where C stands for Composed. Roughly speaking, it uses precomposed characters that include accents and other modifiers rather than separate letter and modifier code points. Inclusion The second technique is inclusion, the principle that specific characters are deliberately included in the allowed set, rather than starting with everything and trying to delete the problematic ones. The IDNA specifications identify the code points that are allowed in domain names, which are generally intended to include letters and digits used in a wide variety of languages, as well as—in some cases—additional characters needed to combine or format them. They deliberately exclude all the other Unicode code points such as punctuation and emoji. A UTF-8 string that complies with all of the IDNA rules is called a ULabel. ACE Encoding The third technique is ASCII Compatible Encoding (ACE). Since a lot of existing software (not just mail software) only handles ASCII, IDNA created an alternate ASCII encoding called an A-Label. Every valid U-Label corresponds to a unique A-Label and vice versa. The A-Label is stored in the DNS, while the U-Label is typically entered by users and displayed to them. An A-Label is in the form xn--text, where xn-- is a prefix indicating that a label is an ALabel, and the text is an ASCII-encoded version of the U-Label, using a scheme known as punycode. IDNA is widely supported in web browsers, which will turn UTF-8 names in their address bars into A-labels before looking them up. Scripts and LGR The fourth technique is comprised of scripts and Label Generation Rules (LGR.) A script is a collection of characters used to write a language. The relationship between scripts and languages can be complex—some scripts such as Cyrillic are used for several languages, while some languages such as Japanese are written in multiple scripts. Label Generation Rules define the set of Unicode characters valid for a particular language. The main point of LGRs is to avoid mixed script names that are confusing for users (e.g., mixtures of Latin and Cyrillic), and to identify variant characters that look different but have the same meaning. UASG012: Email Address Internationalization (EAI): A Technical Overview  LGRs are not formally a part of IDNA2008, but IETF standards recommend using them. Most top-level domain registries have LGRs for each of the languages in which they accept registrations. IANA keeps a repository of them at  UTS#39, Unicode Security Mechanisms, offers advice on restricting mixing of scripts. Its Highly Restrictive restriction level is a conservative and widely used rule for identifiers. The part of an email address after the @ is a domain name, so A-labels are valid there. But the part of the email address before the @, the local-part, is not a domain name, and for a variety of reasons, a UTF-8 local-part cannot be encoded as punycode or an A-label.2 To have proper internationalized mail, we need an extension to the mail system to handle UTF8 in the local-part part of the address, as well as in the other nooks and crannies that MIME doesn’t handle. MIME mail MIME (Multipurpose Internet Mail Extensions), the first major extension to mail, appeared in 1992. Before MIME, the body of a mail message was just a block of unstructured ASCII text. MIME provided a way to treat the mail body as a group of structured blocks of data, some of which might be text, while others might be pictures, documents, or any other sort of data that could be stored in a file. MIME provides standard ways to encode any kind of data. When pictures or other files are attached to a mail message, it’s done with MIME. MIME overlays a structure of message parts on the block of unstructured text. A message can be one part or several, the parts can be related in different ways, and each part can have a type. Typical types are text/plain and text/html for plain or HTML-formatted text, or application/pdf for an attached PDF file. A message with more than one part can be multipart/alternative, different versions of the same thing (typically unformatted and formatted text), or multipart/related, typically text and attachments. Every MIME text part can specify a character set such as UTF-8, which allows UTF-8 message bodies even in legacy mail. MIME also added a feature called 8BITMIME, which allows the transfer of messages that include 8-bit characters in message bodies so long as the body is still lines of text with CR and LF at the end. This allows the use of UTF-8 text since all ASCII characters, including CR and LF, are also UTF-8 characters. In principle, mail server support of 8BITMIME is optional, but in practice, all current mail servers support it. Messages can also use quoted-printable or base64 encoding to represent any data including UTF-8 in legacy messages. MIME also provides a way to specify encoded character sets in the unformatted parts of message headers such as the Subject: line, using the same character sets and encodings that are allowed in text bodies. These are called encoded-words. 2 Since mail programs accept and display local parts as-is, users would see the meaningless punycode or A-label rather than the intended UTF-8 address. Even worse, users would have to enter the characters in the punycode or A-label when typing an address. UASG012: Email Address Internationalization (EAI): A Technical Overview  For example, this subject line is an encoded-word in UTF-8. This example includes a UTF-8 character hex C2 B0, which is a raised small letter "o". Subject: =?utf-8?Q?Your_reservation_N=C2=B0_F39-04XS?= Subject: Your reservation No F39-04XS MIME encoded-words can be used in most mail headers visible to users, including the Subject: and the comment parts of address headers such as To: and From:, but it can’t be used in email addresses in legacy mail, which still have to be ASCII. It’s worth emphasizing this last point: other than addresses, almost everything in a mail message can already use UTF-8 via MIME. A first look at EAI mail The technical differences between legacy and EAI mail are quite small. The most important difference is that email addresses (the local-part and/or domain name) can contain UTF-8 as well as ASCII. The local-part part of an address can contain any printable UTF-8 characters. The characters in a domain name are limited to those allowed by IDNA2008. Another difference is that most parts of a message can be UTF-8 rather than ASCII. The contents of header fields such as To:, From:, and Subject: can be UTF-8, although the field names are still restricted to ASCII. The contents of a message can be UTF-8 without needing any special encoding. There are a few other differences, but these are the most important ones. Since there is no way for a legacy mail system to handle UTF-8 addresses in a message envelope, or UTF-8 addresses in mail headers, EAI had to modify both SMTP and message formats to handle the new address forms. Transmitting EAI mail EAI creates a conceptually parallel mail stream for EAI mail. When one computer transmits an EAI message to another, such as when an MUA submits a message to an MSA, or an MTA transmits a message to another MTA, it needs to be sure that the receiving system can deal with it. (We say conceptually parallel because any EAI mail server can support legacy mail.) The standard MUA→MTA submission and MTA→MTA SMTP have defined an extension feature called SMTPUTF8. If a mail server supports SMTPUTF8 it can handle EAI mail; if not, it can’t. When the sending computer first connects, the receiving computer sends it a list of supported extensions (see EHLO in Appendix C below) and the sending computer checks to see if SMTPUTF8 is in the list. UASG012: Email Address Internationalization (EAI): A Technical Overview  This picture shows the two conceptually separate mail streams, EAI and legacy SMTP. The solid diagonal line indicates that any EAI mail server is also a legacy mail server; that is, any legacy sender can send to a legacy address on an EAI server. The dotted diagonal line indicates that in some cases (not many), EAI mail can be turned back into legacy mail. Recognizing EAI messages Since there are likely to be parallel EAI and legacy mail streams for a long time to come, it will sometimes be necessary to distinguish between EAI and legacy messages. There are two ways to do this. One is to look at the message you need to identify as EAI. If there are UTF-8 characters in any of the envelope addresses, or UTF-8 characters in any of the headers in the message, it’s an EAI message.3 In addition, the end of the header is marked by an empty line, coded as the four characters CR LF CR LF. This identification process could potentially be slow if a message’s headers were large, or if it would require reading the message from a disk file. The other way of distinguishing an EAI message is to keep its EAI status as part of the message’s metadata. The metadata already includes the envelope addresses, and—in many systems—other information such as receipt time, whether it’s been read or replied to, and whether it’s considered junk. In some cases, one more indicator for EAI status would be easy to include. 3 This is easy to do in software because all UTF-8 character codes are greater than 0x80, whereas ASCII codes are less than 0x80. UASG012: Email Address Internationalization (EAI): A Technical Overview  Technical topics for EAI mail Most changes are in the SMTP session and in message headers, but there are a few changes in user mail programs, and some new options for the message bodies, too. Assigning and interpreting EAI mail addresses Many of the conventions from ASCII addresses carry over to EAI mail addresses: EAI local parts can contain any printable UTF-8 characters, while the domain parts are still domain names but IDN names can be written as UTF-8 U-labels. Any address with UTF-8 in the local-part, the domain, or both is an EAI address. While the email standards say that a local-part can contain any sequence of UTF-8 characters up to 64 bytes long, some local-parts are a lot easier for users to remember and type than others. The IETF PRECIS4 (Preparation and Comparison of Internationalized Strings) working group created standard ways to handle string input used in applications. It defines classes of strings for different applications. The Identifier Class is intended, as its name suggests, for strings used as identifiers. The class has a profile UsernameCaseMapped which matches mailbox names fairly well, including case-insensitive letters and digits but not spaces or punctuation. PRECIS also defined preparation rules to preprocess user input, in order to deal with multiple versions of characters such as upper and lower case or full- and half-width letters. An additional advantage of using a Username profile is that internationalized usernames for POP and IMAP servers (described below) have to be PRECIS usernames, and this allows the user’s mailbox to be used as the POP/IMAP username. See the list of RFCs in Appendix D for links to detailed PRECIS specifications. The Unicode consortium offers similar advice in UTS#39 Unicode Security Mechanisms, which offers advice for email addresses in section 3.3. In some cases it may be useful to assign both an EAI and a legacy address for a mailbox. (See Downgrading, below.) In some cases there may be a straightforward transliteration, such as борис@domain to boris@domain or 李伟@domain to liwei@domain. In other cases, there may be no natural way to transliterate, and the two names may have no obvious connection. Mail standards require that systems treat addresses of mailboxes on other systems as opaque identifiers; that is, to pass them along as is without trying to interpret or modify them. This means that systems must not even attempt to normalize text to NFC, since there is no promise that the recipient system uses that normalization, or any normalization. But the standards allow the delivering system a great deal of flexibility in handling mail addressed to its own users. For legacy addresses, upper- and lower-case ASCII are usually treated as the same, and systems often accept minor variants of an address, such as 4 Pronounced as the French précis, roughly like pray-see. UASG012: Email Address Internationalization (EAI): A Technical Overview  addresses with or without periods, apostrophes, or other punctuation (e.g., J.O’Brian@ and J.obrian@ and jobrian@ can deliver to the same mailbox). EAI mail systems can allow similar flexibility in UTF-8 addresses. See the PRECIS documents for advice on preparing and normalizing string input. Storing EAI mail The traditional folder structure used for legacy mail doesn’t change with EAI, but the folder names can now be UTF-8, and metadata associated with messages such as To: and From:addresses and Subject:headers can be UTF-8 as well. The PRECIS FreeFormText class, defined in RFC 8264, is intended for free-form strings such as “human-friendly nicknames” that can be useful for folder names. This allows a wider range of text than the Identifier class, including spaces and some punctuation. MUAs and EAI mail The changes to MUAs to handle EAI mail are not large. In all the places where a user can enter a legacy mail address, such as To:and Cc: headers and address book entries, any validation of addresses at the time of entry must allow EAI addresses. EAI addresses may contain Left-to-right (LTR), Right-to-Left (RTL) or bidirectional (bidi) text, when for example, an address has an RTL local part and an ASCII domain name. MUAs must be prepared to display such addresses when they occur in header fields or in the message body. A discussion of the best ways to display bidi text is beyond the scope of this document. See Appendix D for references. When user-entered text in messages is linkified by the MUA, the linkification process should treat all domain names and all email addresses the same. Address books Address books might provide a way to mark whether or not an address is able to receive EAI mail. While any EAI address can receive EAI mail, legacy addresses may or may not. If a user receives an EAI message, the sender of the message can be marked as EAI-ready. If a contact in an address book has both an EAI and a legacy address, the EAI address is likely to be preferred for EAI mail, although the user should be able to override the choice. Mail addresses on the web Many websites accept email addresses through web forms, to be used for sending confirmations, adding to mailing lists, and other purposes. The addresses are generally validated either by javascript in the web page, or by code on the server to which the form is sent. Javascript typically uses regular expressions to check the address syntax. A fairly complete set of address expressions are in the IETF Internet draft draft-seantek-mailregexen. When a server receives an address, it should do some checks beyond what the javascript can do. If the domain part of the address is in UTF-8, it should normalize it following IDNA2008 rules and then verify that the domains are valid U-labels by converting them to Alabels. If the conversion fails, the address is invalid and the user needs to correct it. Once UASG012: Email Address Internationalization (EAI): A Technical Overview  the server has the A-label version of the domain, it can look up the domain in the DNS to be sure it exists and that it has MX, A, or AAAA DNS records. If the domain doesn’t exist, or doesn’t have MX, A, or AAAA records, it’s not valid for mail. There is no way to validate the local part of an address other than sending mail to the address and seeing if the user receives the message. (In particular, doing a partial SMTP session to see if a RCPT TO: command succeeds is not a reliable check.) Sending a confirmation message to check that the address is valid and the person at that address is the one who provided the address is an email best practice whether or not the address is EAI.5 Email addresses can appear in mailto: URIs in formatted text. If an EAI address appears in a mailto: URI, the URI specifications6 require that any non-ASCII characters must be percentencoded in the URI. If an address were 猫王@普遍接受-测试.世界, the mailto: URI would be: mailto:%e7%8c%ab%e7%8e%8b@%e6%99%ae%e9%81%8d%e6%8e%a5%e5%8f%97%2d%e6%b5%8b %e8%af%95.%e4%b8%96%e7%95%8c The Chinese characters are percent-encoded but the ASCII dot and at-sign are not. The domain name can be a U-label or an equivalent A-label, e.g.: mailto:%e7%8c%ab%e7%8e%8b@xn----f38am99bqvcd5liy1cxsg.xn--rhqv96g Sending, delivering and picking up EAI mail The following discussion assumes the reader is already familiar with the way that SMTP and SUBMIT work. See Appendix C for an overview of SMTP. When an MTA uses SMTP to send a message to another MTA, or an MUA SUBMITs a message to an MSA, there a a few changes to the SMTP and SUBMIT protocols. EAI makes the same changes to SMTP and to SUBMIT, so we describe the changes together here. The first difference is that the receiving computer includes the keyword SMTPUTF8 in the list of extension keywords to say that it can handle EAI mail: S: <connect> R: 220 receive.net ESMTP S: EHLO sender.org R: 250-8BITMIME R: 250-SMTPUTF8 R: 250 PIPELINING The order of the keywords doesn’t matter, but SMTPUTF8 has to be in the list. (Every EAI mail server must also support 8BITMIME, but all modern servers do anyway.) 5 See M3AAWG Sender Best Common Practices Version 3.0. 6 Defined in RFC 3987. UASG012: Email Address Internationalization (EAI): A Technical Overview  Next, when sending the return address, the MAIL FROM: command includes an SMTPUTF8 keyword to indicate that this message is an EAI message. UTF-8 addresses are sent as-is. S: MAIL FROM:<猫王@普遍接受-测试.世界> SMTPUTF8 R: 250 Sender accepted If the body of the message contains 8-bit data such as UTF-8, the sender may indicate it in the MAIL FROM, although it’s not required. S: MAIL FROM:<猫王@普遍接受-测试.世界> SMTPUTF8 BODY=8BITMIME R: 250 Sender accepted The rest of the mail session is unchanged from legacy mail, other than allowing UTF-8 in the envelope recipient addresses and the message headers. If a sending computer is trying to send an EAI message, and the EHLO response from the server doesn’t contain SMTPUTF8, that server can’t handle EAI mail and the delivery fails. Similarly, if the receiving computer rejects the MAIL FROM that includes a SMTPUTF8 keyword, the delivery fails. MTAs and incoming A-label and U-label addresses An MTA usually handles mail for multiple specific domains.7 An EAI mail server should accept mail both for the A-label and U-label versions of the domains whose mail it accepts. While EAI senders should use the U-label, legacy senders will use the A-label, and it’s also possible that poorly configured EAI senders will, too. Once a message is received, the address should be treated the same whether the address was an A-label or a U-label. An easy way to do that is to normalize incoming addresses so they’re all A-labels or all U-labels before subsequent processing. POP and IMAP with EAI mail POP and IMAP servers that support EAI need two kinds of changes. The first change allows UTF-8 in usernames and passwords as well as IMAP folder names and search strings. In each case, the server needs to be able to tell clients that it supports the new features. The other change allows POP clients to fetch EAI messages, and IMAP clients to fetch messages and store them back to the server. This requires that the client tell the server that it can handle EAI messages. 7 Some servers are both an MTA and an MSA. If a sender authenticates before sending mail, the server is being used as an MSA, so it will accept and relay mail to addresses in any domains. An MTA that accepts and relays mail for any domain without needing authentication is known as an open relay, and is likely to be abused by spammers and blacklisted. UASG012: Email Address Internationalization (EAI): A Technical Overview  Both POP and IMAP support a variety of ways to send login credentials. Each has a command to send a plain text username and password as well as a more complex authentication command that can use a variety of security schemes known collectively as SASL, for Simple Authentication and Security Layer.8 POP3 support for EAI POP3 allows client MUAs to fetch mail from mail servers, and is intended to be easy to implement on both servers and clients. POP3 uses a sequence of four-letter commands and simple responses. Clients use the CAPA command to get a list of available capabilities and—for some capabilities—options. The basic UTF8 capability indicates that the server can handle EAI mail. The “UTF8 user” capability (that is, UTF8 with the “user” option) means that it can also handle UTF-8 login usernames and passwords. Any UTF-8 username and password must be prepared using the PRECIS username profile (or its predecessor, SASLprep) and be sent with an AUTH command that uses a SASL mechanism. Once the client has logged in, it sends a UTF8 command to tell the server that it (the client) can handle EAI messages. After that, the session is the same as for legacy clients. If a client does not send a UTF8 command but the server has EAI messages, the server either omits EAI messages from the list of available messages, or downgrades them. (See the Backward Compatibility section below for more about downgrading.) POP3 only handles a single mailbox per connection, so there are no folder names to deal with. IMAP support for EAI IMAP has a complex design that allows client MUAs to manage multiple mailboxes on remote servers. The client can use complex commands to manage large mailboxes on the server such as SEARCH to look for messages that match various criteria, and SORT and THREAD to control the order messages are returned from the server to the client. Over the years there have been several attempts to add internationalization features to IMAP; these coexist uneasily. Like POP3, IMAP uses capabilities to indicate which optional features a server supports. An IMAP server sends a list of initial capabilities in the greeting message when the client first connects, and another list after the client logs in. (Many capabilities are only available after a client logs in.) The client then sends an ENABLE command with a feature name to tell the server that it wants to use that feature. 8 SASL is defined in RFC 4422, and the various mechanisms are listed in the IANA SASL Mechanisms registry. UASG012: Email Address Internationalization (EAI): A Technical Overview  For a long time IMAP has had features to allow non-ASCII text in some contexts and different collating sequences for SORT and THREAD, but they are clumsy to use and often slow, so clients rarely use them. In 2013 IMAP added nearly full support for UTF-8 with features UTF-8=

ACCEPT

 and UTF8=ONLY. If a server offers UTF-8=

ACCEPT

 and the client enables it, the client and server can send each other UTF-8 in most places that required ASCII before. That includes mailbox names and mail messages sent from the server to the client, and mailbox names, search strings, and mail messages sent from the client to the server. Since the client cannot enable UTF-8=

ACCEPT

 until after it logs in, the IMAP LOGIN: command is still ASCII-only. The IMAP AUTHENTICATE command allows SASL authentication methods that handle UTF-8, so an EAI client can use AUTHENTICATE: to log in, then enable UTF-8=

ACCEPT

. If the server offers UTF-8=ONLY, it is saying that it only provides EAI-compatible service. The client must enable UTF-8=

ACCEPT

 or disconnect. Since ASCII is a subset of UTF-8, the client can access both ASCII and EAI folders and messages. If a server offers UTF-8=

ACCEPT

 but the client does not enable it, the server has the option to downgrade UTF-8 mailbox names and EAI messages. See Backward Compatibility, below. EAI message headers Changes to message headers in EAI mail range from none to very extensive, depending on the header. See Appendix A for advice on individual headers. Headers with addresses Headers with addresses include From:, Sender:, To:, Cc:, Bcc:, Reply-To:, Resent-From:, Resent-To:, Resent-Cc:, and Resent-Bcc:. All have the same syntax, i.e., a comma-separated list of addresses and optional comments. The addresses in EAI messages can have any printable UTF-8 text in the local part, and U-labels as well as Alabels and ASCII hostnames in the domain part. U-labels are preferred over A-labels, since human users can read them. UTF-8 text in the comments can be MIME encoded as in legacy mail, but does not have to be. Since the unencoded UTF-8 is shorter, it is preferred. Header fields that users see Some header fields are free text intended for users to read, such as Subject: and Organization:. They can contain any printable UTF-8 text. The text should be unencoded UTF-8, but (as in legacy messages) can also be MIME encoded-words. Header fields with contents for machines Some header fields, such as Date: and Message-ID:, are intended for computers, not for people. In general, there is no advantage to using non-ASCII characters in those headers, and doing so makes it harder to send mail to legacy systems. Even though content of the Date: header has a form familiar to English speakers, it is in a rigid fixed format defined in RFC 5322, which must be followed exactly. MUAs often parse the headers and display the dates in a convenient localized form, translating from the fixed UASG012: Email Address Internationalization (EAI): A Technical Overview  form in the message. Other headers that contain dates such as Resent-Date are treated the same way. The Message-ID: header contains a unique string that identifies the message. Mail software can check the Message-ID: in two messages to see if they are duplicates. Reply messages put the original Message-ID: into References: and In-Reply-To: headers that let MUAs group related messages together. The syntax of a Message-ID: is similar to an email address in brackets, like <text@text>. Most mail systems create Message-IDs with their own domain name to the right of the @ sign and pseudo-random text to the left. Although it is valid to use UTF-8 characters in Message-IDs, it’s not a good idea, since it makes it impossible for a legacy message to refer to the EAI message in an In-Reply-To: or References: header. IDN domain names in Message-IDs should be represented as ASCII A-labels rather than U-labels. Note: Even though Message-IDs resemble email addresses, they are actually just strings with no address meaning. It is not possible to downgrade a Message-ID; if you change Ulabels in a Message-ID into A-labels, that is a different Message-ID unrelated to the original. Received headers Every time a message is transferred from one computer to another by SMTP, the receiving computer puts a Received: header at the top of the message. The header identifies the sending and receiving computers (“from” and “by”), the transmission protocol (“with”), a timestamp, and often other information. Here’s a typical example for a message sent via SMTP using TLS encryption: Received: from mail.mit.edu ([128.31.0.31]) by mail1.iecc.com ([64.57.183.56]) with ESMTPS via TCP port 40060/25 id 586470169; 15 Feb 2018 02:28:32 -0000 The “with” clause indicates which transport was used to transport the message. Currently the most common are those listed below. When a message uses EAI transport—that is, with an SMTPUTF8 tag on the MAIL FROM: that introduces the message— the “with” value changes to note the EAI transport. Legacy transport EAI transport Meaning ESMTP UTF8SMTP SMTP session starting with EHLO ESMTPS UTF8SMTPS ESMTP with TLS encryption ESMTPA UTF8SMTPA ESMTP from an authenticated sender (typically for SUBMIT) ESMTPSA UTF8SMTPSA ESMTPA with TLS encryption So, for example, a message sent using EAI SMTP and TLS would have this different Received: header. UASG012: Email Address Internationalization (EAI): A Technical Overview  Received: from mail.mit.edu ([128.31.0.31]) by mail1.iecc.com ([64.57.183.56]) with UTF8SMTPS via TCP port 40060/25 id 586470169; 15 Feb 2018 02:28:32 -0000 While users don’t usually see the Received headers, they are invaluable in tracking transport and delivery issues. The “with” values make it easy to tell which transports used EAI and which didn’t. If it seems odd that the SMTP extension keyword is SMTPUTF8 but the Received “with” tag defined in the same document is UTF8SMTP, yes, it is. MIME headers Most messages have more than one part, such as alternative plain text and HTML versions or attached files. The parts in the message are separated by a boundary string which is defined in a Content-Type: header. For example, these lines might appear in the message header: MIME-Version: 1.0 Content-Type: multipart/alternative; boundary="b1_d9ef97d65ef88703f84b0a36e52aa4a2" And these in the message body: --b1_d9ef97d65ef88703f84b0a36e52aa4a2 Content-Type: text/plain; charset=utf-8 … text version of the message ... --b1_d9ef97d65ef88703f84b0a36e52aa4a2 Content-Type: text/html; charset=utf-8 … HTML version of the message ... --b1_d9ef97d65ef88703f84b0a36e52aa4a2-Each part starts with the boundary string, and then a Content-Type: header with the type of the material in the part, the encoding, and sometimes other information such as the suggested filename for an attached file. An optional Content-Description: header contains free text about the MIME part, and Content-ID: contains an ID with the same syntax as a Message-ID: that allows one MIME part to refer to another. EAI makes almost no changes to MIME headers, and EAI messages should continue to use ASCII characters as boundary strings. UTF-8 may appear in optional Content-Type: fields such as the suggested filename for an attached file, and in the text in ContentDescription. Handling and reporting delivery failure UASG012: Email Address Internationalization (EAI): A Technical Overview  Whenever one computer sends a message to another using SUBMIT or SMTP, things can fail. As the sending computer sends commands, the receiving computer sends responses saying whether each command succeeded or failed. In most cases, if any of the commands fail, sending the message fails.9 If a message is rejected inline, during an SMTP or SUBMIT session, specific error codes indicate why it was rejected. EAI adds some new rejection codes to indicate that it was rejected because a recipient does not accept an EAI message. The codes are different depending on which SMTP command provoked the rejection: ● 550 cannot accept EAI sender 5.6.7 (in response to MAIL FROM) ● 553 cannot accept EAI recipient 5.6.7 (in response to RCPT TO) ● 554 some recipients cannot accept EAI 5.6.9 (after the end of DATA) After the receiving computer accepts a message, it either has to deliver the message, or send back a Delivery Status Notice (DSN) to the address in the MAIL FROM: command. Although mail systems try to reject undeliverable mail during the SMTP or SUBMIT session, some DSNs are unavoidable. Assume a user uses an MUA to create an EAI message and submits it to the user’s own mail system. That system’s MTA uses SMTP to relay it to the recipient’s system. If the recipient’s system turns out not to accept EAI mail, the SMTP session will fail, and then the user’s system has to send a DSN back to the user’s MUA. The format of DSNs for legacy messages is defined by RFC 3464, and extended to EAI messages by RFC 6533. A DSN is a mail message in a specific format, containing a MIME multipart/report structure with three parts: a text explanation for a human recipient; a fixedformat, machine-readable section describing what went wrong; and a copy of the failing message, or at least its headers. 9 If a message has several recipients, the sender can send the message even if some of the recipient addresses are rejected, so long as at least one is accepted. It’s a quality of implementation decision whether to send anyway or stop and go back to the user to fix the addresses. UASG012: Email Address Internationalization (EAI): A Technical Overview  A DSN might be returned a few seconds after the initial message was sent, or it might take hours or occasionally days if a recipient system is unavailable and an intermediate system retries the delivery several times before giving up. Backward compatibility For the foreseeable future EAI mail will have to coexist with legacy mail. While an EAI mail system can accept any mail from legacy mail systems, legacy systems can only accept legacy mail. EAI and legacy recipients When a user sends a message to a correspondent with an EAI address or to several EAI correspondents, they can obviously all accept EAI mail. If the correspondent has an ASCII address, and the address is in the user’s address book, it might be marked as EAIcompatible or not. In the absence of that information, one possibility is to be conservative and send a legacy message, while the other is to send an EAI message, hope that it works, and report the failure if it doesn’t. As discussed in the previous section, if a message cannot be delivered, the sending system may get an immediate failure code, or the failure report may come back later in a DSN, depending on the architecture of the system. If a message has more than one recipient, some recipients may accept EAI messages while others do not. In that case the sending system may try to create a downgraded message and send that to the non-EAI recipients. Note that SMTP makes no distinction among To:, Cc:, or Bcc: recipients on a message. The process of downgrading is the same regardless of where—if anywhere—the message header mentions the non-EAI recipient. Hence the process of downgrading and resending depends only on whether there are non-EAI recipients. Whether to downgrade The downgrading advice in the following sections is completely optional. A compliant EAI system need not do any downgrading at all. While the EAI standards allow senders to downgrade messages, they neither encourage nor discourage it. A reason to downgrade is that legacy recipients can get approximate copies of messages they couldn’t get otherwise. But a reason not to downgrade is that downgrading messages loses some of the information, and recipients of downgraded messages may find them confusing or frustrating. It is also not possible to tell reliably whether a recipient with an ASCII address can receive EAI mail, so a system that downgrades is likely to guess wrong some of the time and send downgraded messages to people who could have accepted the EAI original. Another problem is that downgrading removes EAI addresses from message headers. In some cases it is possible to replace them with substitute addresses, but more often an address is just gone. Without a substitute address, recipients cannot reply to the message, put the person in their address books, or do any of the other things they do with addresses in incoming mail. Downgraded messages may be handled poorly by mail systems that do not expect From: header fields that don’t contain an address. If messages are downgraded automatically, the sender is likely to be unaware that some or all of the recipients of the UASG012: Email Address Internationalization (EAI): A Technical Overview  message have gotten a downgraded version, and users may find it confusing that different recipients got different versions of the message. Where mail can be downgraded When an MTA attempts to send a message to a recipient, the attempt may fail because the recipient MTA doesn’t offer SMTPUTF8, or rejects the message with a status code that indicates that the recipient doesn’t accept EAI mail. At that point the MTA might attempt to create a downgraded version of the message to send to the recipient. In theory any MTA in the message’s path might do this, but the result is more likely to be useful if the MTA can find substitute addresses for the EAI addresses in the downgraded message. The most likely situation for a successful downgrade is a webmail system that integrates the MUA, MSA, and outgoing MTA into a single package. Another place that messages might plausibly be downgraded is in mailing list manager software. If some subscribers to a list can accept EAI mail and some can’t, the list software might create a downgraded version for legacy recipients. General downgrade techniques The EAI standards describe two methods of downgrading received EAI messages on POP or IMAP servers. These two approaches are also, with minor changes, suitable for downgrading messages by senders with messages for non-EAI recipients. RFC 6857, Post-Delivery Message Downgrading for Internationalized Email Messages, describes a complex scheme that creates headers such as Downgraded-To: and Downgraded-From: that are intended to include everything that was in the message in a way that could be reversed later. RFC 6858, Simplified POP and IMAP Downgrading for Internationalized Email, describes a much simpler scheme that preserves EAI information where convenient, but does not try to preserve every detail. We recommend the simpler RFC 6858 approach. Headers and bodies In most cases, only the message’s headers need to be downgraded to be acceptable to nonEAI mail systems. In theory there could be systems that only accept 7-bit ASCII mail, but in practice all mail systems now support 8BITMIME, so they can accept UTF-8 in message bodies. Downgrading headers with addresses Headers with addresses such as From:, To:, and Resent-Cc: contain addresses and optional comments. Since the comments can be encoded words that are valid in legacy messages, only the addresses need special handling when downgraded. Downgrading a UTF-8 address has two steps: determine whether there is a substitute ASCII address, and then rewrite the header appropriately. If the address is one managed by the local system (generally the case for addresses in the From: header), there may be a list of locally equivalent EAI and ASCII addresses. If so, find the equivalent ASCII address in that list. Also, if the user has an address book that is available at the time of the downgrade, the address book may have a substitute address for the EAI address. UASG012: Email Address Internationalization (EAI): A Technical Overview  In addition, there is one uncommon case where it is possible to downgrade an address mechanically to a substitute ASCII address. If an address is of the form <ascii@Ulabels>— that is, an ASCII local-part and a UTF-8 domain-part—it is permissible to replace the U-labels in the domain with A-labels, producing an ASCII address. This is the only mechanical downgrade possible. In particular, there is no mechanical downgrade possible from a UTF-8 local-part. If there is a substitute address, downgrade the address by replacing the original address with the ASCII substitute. If there is no substitute, downgrading the address removes the original address from the header and replaces it with an empty address group, written as a colon followed by a semicolon :;.10 It is possible to copy the original EAI address into an address comment to show the recipient what the address was, but the legacy recipient cannot reply to it. Consider this example, where capital letters indicate UTF-8 text, and underlined text means a MIME encoded-word. Before: After: From: “CCCCC” <MMMM@DDDD.DDD> From: “CCCCC MMMM@DDDD.DDD” :; The comment (CCCCC) and the EAI address (MMMM@DDDD.DDD) are moved into an encoded-word comment, and the address is replaced by an empty group to keep the header syntactically valid. The exact details of the encoded-word comment don’t matter because it’s a comment. Note that the rewritten form no longer contains an address that the recipient can reply to. This example is a From: address but the same modifications work on all address headers. If there is more than one address in an header, handle each one separately, converting EAI addresses and leaving legacy addresses alone. Downgrading other headers that users see Headers displayed to users can use MIME encoded-words to represent UTF-8 text. For any UTF-8 text in a message header, turn any UTF-8 into encoded-words. This includes text in Subject:, Comment:, and Keyword: headers, and many semi-standard headers such as Organization:. Downgrading headers that users do not see As mentioned above, Message-ID: headers should not have non-ASCII characters. If the Message-ID nonetheless does have non-ASCII characters, delete it and create a new one. (Since the ID is an opaque string, there’s no benefit in trying to create a downgraded ID that looks like the original one.) Message-IDs also appear in References: and In-Reply-To: 10 Mail standards originally limited empty groups to specific headers, but RFC 6854 relaxed the rules to allow them anywhere an address can appear. UASG012: Email Address Internationalization (EAI): A Technical Overview  headers. If those headers contain non-ASCII IDs, delete the ID, and if there are no other IDs left in the header, delete the header. If any other headers not shown to users have UTF-8 characters, delete them, since there’s no way to downgrade them and they won’t affect what the user sees. If a MIME Content-Type header, either in the message headers or in the header of a MIME body part, contains a field with non-ASCII text, delete that field. All required fields in these headers are ASCII. If the header has no fields left, delete the header. UASG012: Email Address Internationalization (EAI): A Technical Overview  Downgrading in POP and IMAP If a POP or IMAP mailbox contains EAI messages but the MUA client does not support EAI, the POP or IMAP server has the option of downgrading the EAI messages so the user can see at least an approximation of what was sent. The downgrade process is the same as that described above, except that POP and IMAP servers are unlikely to have substitute addresses. This is addressed in more detail in RFC 6858. Downgrade notes If a downgraded message has a DKIM signature, the downgrade will invalidate the signature, so delete the signature. In some cases it’s possible to re-sign. See the next section. Rather than trying every EAI message sent to a non-EAI address to see if it works, when a message fails, if the recipient address is in an address book, tag the entry as legacy only. (Also provide some way to remove the tag when the recipient system upgrades.) Out-of-office, read receipts, and other autoresponders Mail systems often allow automatic responses for out-of-office and similar notifications. From an EAI point of view, autoresponder mail is like any other mail. If the recipient of the response (that is, the sender of the original message) has an EAI address, or is otherwise known to accept EAI mail, the autoresponse can be an EAI message. Otherwise it should be a legacy message, either created as a legacy message or downgraded from an EAI message. Mail authentication and spam filters As spam becomes an ever-worsening problem, mail systems have added a wide variety of anti-spam features. Among the most effective of those is authentication, showing that the message was in fact sent by its purported sender. For details on EAI and mail authentication beyond the discussion below, see the Internet Draft  SPF authentication SPF (Sender Policy Framework) checks the IP address from which a message was sent against a list of authorized IPs for a domain. The domain checked is the domain in the MAIL FROM: bounce address, or if that address is empty, in the EHLO/HELO argument. A domain publishes its authorized addresses in a TXT record with a fairly complex syntax. The SPF record for icann.org is typical: icann.org IN TXT “v=spf1 ip4:192.0.32.0/20 ip4:199.91.192.0/21 ip4:64.78.40.0/27 ip4:162.216.194.0/27 ip6:2620:0:2d0::0/48 ip6:2620:0:2830::0/48 ip6:2620:0:2ed0::0/48 include:salesforce.icann.org -all” This lists several IPv4 and IPv6 address blocks, and includes all the blocks published at salesforce.icann.org. UASG012: Email Address Internationalization (EAI): A Technical Overview  Using SPF in EAI mail is straightforward. Since the information is published in the DNS, a validator performs the usual IDNA domain lookup, turning U-labels into A-labels and then doing a DNS query. The SPF records themselves don’t contain any UTF-8 so the processing to see whether an IP address matches an SPF record is unchanged. DKIM authentication Sending and relaying MTAs use DKIM to add cryptographic signatures to mail messages. A receiving system can check the signature. If it’s valid, it knows that the message it checked is the same one the signer signed. The signature is placed in a DKIM-Signature header, such as this one on a message from Microsoft: DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com; s=rm1; h=From:Date:Subject:Message-ID:Content-Type:MIME-Version; i=billg@microsoft.com; bh=SwUgUaGo9gVX7cc6F206JZvUfMea/5YYkAej9uuVF6Q=; b=EdBiodGIf4bCmbGEZBQFUa+MCfoPhm138ox5x6iq4FCmITu522v1Q/9t/A+E= The signature is a list of tag=value items. The tag is the domain that applied the signature, and the s= tag is a “selector” used to find the validation key in the DNS. The optional i= tag is an identity meaningful to the signer.11 The bh= tag is a hash of the message’s body, and the b= tag is a signed hash of selected message headers along with the DKIMSignature itself. A receiving system checks the hashes against the received message and the validation key in the DNS to see if the signature is valid. The validation key is stored in the DNS at <selector>._domainkey.<domain>, so in this case, since the s= selector is rm1 and the d= domain is microsoft.com, it would be (omitting some uninteresting details): rm1._domainkey.microsoft.com. TXT "v=DKIM1; k=rsa; p=MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCkHq3ztGIm1R8alD+7oZiaG5mT;" EAI makes some small changes to DKIM signatures. The s= selector and the domains in the d= and i= tags can be U-labels, and the i= string can also be UTF-8.12 This should have no effect when creating DKIM signatures, since the characters in the domains are handled like any other characters in the message. When verifying a DKIM signature, any Ulabels in the d= domain or s= selector must be converted to A-labels for the DNS lookup. If a system downgrades a message, the changes from downgrading will change the message enough that existing DKIM signatures become invalid. If the downgrading happens in an MUA, the message will generally be re-signed as it passes through the MSA. If a message is downgraded in an MSA or MTA, the message should be re-signed if the MSA or MTA has the signing key available. 11 Although the i= tag has the same syntax as an email address, it need not be the address of the person who sent the message, or of anyone else. 12 RFC 6376 says that the domains in signatures should all be A-labels, but this is likely to change. UASG012: Email Address Internationalization (EAI): A Technical Overview  DMARC authentication DMARC is an anti-phishing scheme that uses the authentication results of SPF and DKIM to validate the domain in the From: header. If a domain publishes a DMARC policy in the DNS, receivers check to see if the message has a valid SPF result or DKIM signature for that domain. If so, the message passes. This doesn’t mean it’s not spam, but it does mean it really is from the purported sender. For example, assume the From: header says: From: Bob Smith <bob@example.com> The DMARC validator checks to see if the SPF check is from example.com (that is, the MAIL FROM: address was at example.com) and succeeded, or that the message has a valid DKIM signature with d=example.com. If either is so, the DMARC check succeeds. Once an EAI system has implemented SPF and DKIM, there is little additional work for DMARC. When checking the domain in the From: header, if the domain is an IDN, either the A-label or U-label version of the IDN can match the SPF domain or the DKIM d= domain. Spam filtering EAI makes little difference to spam filtering techniques. Since everything in the message other than the To:/From:/Cc:13 header addresses could already be UTF-8, filters already deal with internationalized text. If a filtering system provides whitelisted and blacklisted sending addresses, those lists should handle EAI addresses, and when checking against incoming mail, should handle both U-label and A-label versions of the domains. One possible source of trouble is empty address groups in downgraded messages. Groups have been allowed in To: and Cc: headers since the 1970s, but have only been allowed in From: headers since RFC 6854 in 2013. There are still some mail systems that consider From: groups to be invalid, in some cases displaying them wrong and in a few cases treating the whole message as spam. 13 Incoming messages do not normally have Bcc headers because they are supposed to be stripped out as a message is sent. UASG012: Email Address Internationalization (EAI): A Technical Overview  Appendix A: Handling message header fields In this table “Substitute or delete EAI address” means to replace the address with a legacy address if possible, otherwise delete the address as described in “Downgrading headers with addresses” above. “Allow UTF-8 text” means literal text in preference to MIME encoded-words. Header Field Name EAI changes Downgrade actions Authentication-Results Allow IDN domains where domains appear Delete if contain UTF-8 Bcc Allow EAI addresses Substitute or delete EAI addresses, delete header if no addresses remain Cc Allow EAI addresses Substitute or delete EAI addresses Comments Allow UTF-8 text Use MIME encoded-words for UTF-8 text Content-Description Allow UTF-8 text Use MIME encoded-words for UTF-8 text Content-ID None Delete if contains UTF-8 Content-Transfer-Encoding None None UASG012: Email Address Internationalization (EAI): A Technical Overview  Content-Type Usually none, possible UTF-8 in optional filename tags Delete any tags with UTF-8 values Date None None DKIM-Signature Allow IDNs in d= i= s= tags, allow UTF-8 in i= local part Delete and re-sign Errors-To Possibly allow EAI addresses Substitute EAI addresses or delete header From Allow EAI addresses Substitute or delete EAI addresses In-Reply-To None Delete UTF-8 message-IDs, delete header if no messageIDs remain. Keywords Allow UTF-8 text Use MIME encoded-words for UTF-8 text List-Archive Mailto: URI can contain EAI addresses Substitute or delete EAI addresses, delete header field if no URIs remain List-Help Mailto: URI can contain EAI addresses Substitute or delete EAI addresses, delete header field if no URIs remain List-ID None. (UTF-8 text not recommended.) Delete if contains UTF-8 text UASG012: Email Address Internationalization (EAI): A Technical Overview  List-Owner Mailto: URI can contain EAI addresses Substitute or delete EAI addresses, delete header if no URIs remain List-Post Mailto: URI can contain EAI addresses Substitute or delete EAI addresses, delete header if no URIs remain List-Subscribe Mailto: URI can contain EAI addresses Substitute or delete EAI addresses, delete header if no URIs remain List-Unsubscribe Mailto: URI can contain EAI addresses Substitute or delete EAI addresses, delete header if no URIs remain Message-ID None Should be none, delete and replace any UTF-8 messageID header MIME-Version None None Organization Allow UTF-8 text Use MIME encoded-words for UTF-8 text Received Allow IDN domains and EAI mailboxes Delete if contains UTF-8 text References None Delete UTF-8 message-IDs, delete header if no messageIDs remain. Reply-To Allow EAI addresses Substitute or delete EAI addresses, delete header field if no addresses remain UASG012: Email Address Internationalization (EAI): A Technical Overview  Resent-Bcc Allow EAI addresses Substitute or delete EAI addresses, delete header field if no addresses remain Resent-Cc Allow EAI addresses Substitute or delete EAI addresses Resent-Date None None Resent-From Allow EAI addresses Substitute or delete EAI addresses Resent-Message-ID None Should be none, delete and replace any UTF-8 ID Resent-Sender Allow EAI addresses Substitute EAI address or delete header field Resent-To Allow EAI addresses Substitute or delete EAI addresses Return-Path Allow EAI address Delete if contains UTF-8 Sender Allow EAI addresses Substitute EAI address or delete header field Subject Allow UTF-8 text Use MIME encoded-words for UTF-8 text UASG012: Email Address Internationalization (EAI): A Technical Overview  To Allow EAI addresses Substitute or delete EAI addresses Appendix B: Summary of steps necessary to move to EAI Here is a summary of software changes to add EAI capabilities to various kinds of mail software. Changes to MTAs ● ● ● ● Distinguish EAI from legacy messages, either by external tag or by scanning for UTF-8 in headers As a server, advertise SMTPUTF8 EHLO keyword, accept SMTPUTF8 keyword on MAIL FROM:, put UTF8SMTP in Received: header As a client, look for SMTPUTF8 EHLO keyword, send SMTPUTF8 keyword on MAIL FROM: If sending an EAI message fails, downgrade the message and resend, but only if MTA has necessary address book info and DKIM signing keys Changes to MSAs ● ● ● Advertise SMTPUTF8 EHLO keyword Distinguish EAI from legacy messages by MAIL FROM: keyword If sending an EAI message fails, downgrade the message and resend, but only if MSA has necessary address book info and DKIM signing keys Changes to MUAs ● ● ● ● Allow UTF-8 in addresses in messages Allow UTF-8 in addresses in address books, allow entries to have both EAI and legacy addresses Look for SMTPUTF8 EHLO keyword from MSA, add SMTPUTF8 keyword on MAIL FROM:, don’t send EAI messages to MSAs that can’t handle them If sending an EAI message fails, downgrade the message and resend, but only if MUA has necessary address book info IMAP Servers ● ● ● ● Support UTF-8 folder names Tag messages as EAI or legacy, either by tag set when message created or by scanning headers Add UTF-8=

ACCEPT

 IMAP feature (Optional) Downgrade EAI messages as needed for legacy clients UASG012: Email Address Internationalization (EAI): A Technical Overview  POP Servers ● ● ● Tag messages as EAI or legacy, either by tag set when message created or by scanning headers Add UTF8 capability and UTF8: command (Optional) Downgrade EAI messages as needed for legacy clients Appendix C: How does SMTP work? SMTP uses a series of commands and responses to transfer a message from one mail server to another. The commands and responses are all ASCII characters (other than EAI addresses.) Responses start with a three-digit number which provides the meaning of the response, followed by text, which is generally a comment. In the example below, user sam@sender.org is sending mail to ray@receive.net. To keep things simple, the sending host is sender.org and the recipient host is receive.net. First, the sending computer connects, and the receiving computer sends an initial response. The sending computer sends EHLO (extended hello) to identify itself and ask for a list of features that the receiving computer supports: S: <connect> R: 220 receive.net ESMTP S: EHLO sender.org R: 250-8BITMIME R: 250 PIPELINING Code numbers of the form 2xx indicate success. In this example, the recipient host supports two features, 8BITMIME and PIPELINING. Nearly all hosts support these. (8BITMIME allows non-ASCII text in message bodies, PIPELINING allows the sender to send multiple commands without waiting for a receipt for each one.) The sending computer sends a MAIL FROM: command, identifying the sender address to which status and non-delivery reports can be sent, and optionally also other envelope information. S: MAIL FROM:<sam@sender.org> R: 250 Sender accepted The sending computer sends RCPT TO: commands, each with a recipient address to which the message is sent. S:RCPT TO:<ray@receive.net> R:250 Recipient accepted (If there were more than one recipient, there would be a separate RCPT TO: command and response for each one.) The sending computer sends a DATA: command, and then, when the receiving computer responds, it sends the message as a single block of text, the header followed by the entire message including header and body, followed by a line with a single dot which indicates the end of the message. UASG012: Email Address Internationalization (EAI): A Technical Overview  S:DATA R:354 Send your message S:From: sam@sender.org S:To: ray@receive.net S:Subject: lunch S: S:How about lunch at 12:30? S:. R:250 Message accepted 409343fg34 At this point the message is complete, so the sender uses QUIT to end the session. S:QUIT R:221 Sayonara Adding UTF-8 features to the SMTP example EAI makes small changes to the protocol. The server’s response to EHLO contains a UTF8SMTP keyword to indicate that the server supports EAI: S: <connect> R: 220 receive.net ESMTP S: EHLO sender.org R: 250-8BITMIME R: 250-UTF8SMTP R: 250 PIPELINING The client’s MAIL FROM: command includes a SMTPUTF8 keyword to indicate that a message is an EAI message. S: MAIL FROM:<猫王@普遍接受-测试.世界> SMTPUTF8 R: 250 Sender accepted The rest of the SMTP session is unchanged, other than allowing UTF-8 data in mail headers: S:RCPT TO:<ray@receive.net> R:250 Recipient accepted S:DATA R:354 Send your message S:From: 猫王 <猫王@普遍接受-测试.世界> S:To: ray@receive.net S:Subject: 我们要吃午饭吗? S: S:How about lunch at 12:30? S:. R:250 Message accepted 389dck343fg34 S:QUIT R:221 Sayonara UASG012: Email Address Internationalization (EAI): A Technical Overview  Appendix D: Relevant RFCs Most of the specifications for Internet services are developed and maintained by the Internet Engineering Task Force (IETF), a group affiliated with the Internet Society. The IETF’s major publication series is known for historical reasons as Requests for Comments or RFCs. Each RFC is numbered, starting with RFC 1 in 1969 and currently up to about RFC 8300. Some RFCs are standards, while others describe best current practices or report other information relevant to the technical operation of the Internet. The IETF sometimes issues new standards RFCs that update or replace prior standards. When they do, they generally avoid changes that are incompatible with existing standards. All RFCs are available to the public at no charge at the RFC Editor’s web site at  and at many other places around the Internet. Important mail RFCs Here are some of the more important RFCs. For a longer list see UASG 006, For SMTP: ● ● RFC 5321 - Simple Mail Transfer protocol, from one MTA to another (previously RFCs 821 and 2821) RFC 6609 - Mail submission, from MUA to MSA (previously RFCs 2476 and 4409) For mail message formats: ● ● ● ● ● ● ● ● RFC 5322 - Internet Message Format (previously RFCs 822 and 2822) RFC 2045 - Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies RFC 2046 - Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types RFC 2047 - MIME (Multipurpose Internet Mail Extensions) Part Three: Message Header Extensions for Non-ASCII Text RFC 2048 - Multipurpose Internet Mail Extensions (MIME) Part Four: Registration Procedures RFC 2049 - Multipurpose Internet Mail Extensions (MIME) Part Five: Conformance Criteria and Examples RFC 3464 - An Extensible Message Format for Delivery Status Notifications RFC 6854 - Update to Internet Message Format to Allow Group Syntax in the "From:" and "Sender:" Header Fields For POP and IMAP: ● ● RFC 1939 - Post Office Protocol - Version 3 (POP3) RFC 3501 - Internet Message Access Protocol - Version 4rev1 (IMAP4) For IDNs: ● ● RFC 3629: UTF-8, a transformation format of ISO 10646 RFCs 5890, 5891, 5892, 5893, 5894, and 5895 - Internationalized Domain Names for Applications (IDNA) UASG012: Email Address Internationalization (EAI): A Technical Overview  For EAI mail: ● ● ● ● ● ● ● ● RFC 6530 - Overview and Framework for Internationalized Email RFC 6531 - SMTP Extension for Internationalized Email RFC 6532 - Internationalized Email Headers RFC 6533 - Internationalized Delivery Status and Disposition Notifications RFC 6855 - IMAP Support for UTF-8 RFC 6856 - Post Office Protocol Version 3 (POP3) Support for UTF-8 RFC 6857 - Post-Delivery Message Downgrading for Internationalized Email Messages RFC 6858 - Simplified POP and IMAP Downgrading for Internationalized Email For PRECIS and string mapping: ● ● ● ● ● ● ● RFC 8264 - PRECIS Framework: Preparation, Enforcement, and Comparison of Internationalized Strings in Application Protocols RFC 8265 - Preparation, Enforcement, and Comparison of Internationalized Strings Representing Usernames and Passwords RFC 8266 - Preparation, Enforcement, and Comparison of Internationalized Strings Representing Nicknames RFC 7790 - Mapping Characters for Classes of the Preparation, Enforcement, and Comparison of Internationalized Strings (PRECIS) RFC 6885 - Stringprep Revision and Problem Statement for the Preparation and Comparison of Internationalized Strings (PRECIS) RFC 6943 - Issues in Identifier Comparison for Security Purposes UTS#39 - Unicode Security Mechanisms, sections 3.3 Email Security Profiles for Identifiers and 5.2 Restriction Level Detection For SASL (logging in and authenticating for POP, IMAP, and submission): ● ● ● ● RFC 4422 - Simple Authentication and Security Layer (SASL) RFC 4616 - The PLAIN Simple Authentication and Security Layer (SASL) Mechanism The LOGIN SASL Mechanism Internet draft IANA SASL methods registry For URLs and URIs: ● ● RFC 3986 - Uniform Resource Identifier (URI): Generic Syntax. RFC 3897 - Internationalized Resource Identifiers (IRIs) For message authentication: ● ● ● ● RFC 6376 - DomainKeys Identified Mail (DKIM) Signatures RFC 7208 - Sender Policy Framework (SPF) for Authorizing Use of Domains in Email, Version 1 RFC 7489 - Domain-based Message Authentication, Reporting, and Conformance (DMARC) Eaiauth draft - Email Authentication for Internationalized Mail UASG012: Email Address Internationalization (EAI): A Technical Overview  For input and display of RTL and mixed direction text: ● RFC 5893 - Right-to-Left Scripts for Internationalized Domain Names for Applications (IDNA) Appendix E: Other sources of advice ● ● ● ● ● ● UASG documents at  For mail format and specification standards, see email RFCs; see the list above For HTML and other web data standards, see the W3C website at  Stack Overflow for general mail programming,  Discussion lists for mail software. Most lists have online archives; check the archives to see if your question has already been asked and answered. ○ Postfix  ○ Qmail  and  ○ Sendmail  ○ Cyrus IMAP  ○ Dovecot  IETF working group discussion lists. These are useful for questions about RFCs and details of how to implement them, but not for general mail or programming questions. ○ DKIM mailing list, ietf-dkim@ietf.org ○ DKIM operations list, dkim-ops@mipassoc.org ○ DMARC mailing list, dmarc-discuss@dmarc.org ○ SMTP mailing list, ietf-smtp@ietf.org UASG012: Email Address Internationalization (EAI): A Technical Overview  Glossary A-label: An ASCII encoded version of a UTF-8 domain label, in the form xn--stuff where the stuff is a punycode version of the UTF-8. Compare to U-label. Address book: A list of email addresses and related contact information. ASCII Compatible Encoding (ACE): The format used in an A-label, in the form xn--stuff where the stuff is a punycode version of the UTF-8. Authentication: Verifying the source of, or other information about, the origin of a message. Bidi rule: The rule that prohibits combining left-to-right and right-to-left text in a single domain name label. Defined in RFC 5893, section 2. Body: The contents of a message, which follows the headers. The body may be unformatted text, or it may be one or more formatted or encoded MIME parts. Encoded words: A MIME format that represents UTF-8 text (other than addresses) as ASCII in message header lines. Looks like =?utf-8?Q?stuff?=. Envelope: Information that accompanies a message in transit, including the address(es) it is being sent to, and the return address to which error or failure reports can be sent. Field names: The names of mail header fields such as From:, To:, and Subject:. Hostname: a DNS record that identifies a computer on the Internet. The characters in hostnames are restricted to those allowed by the LDH rule IDNA: Internationalized Domain Names in Applications. The rules for characters and their combinations that can appear in UTF-8 domain names. The current version is IDNA2008, defined in RFCs 5891-5895. IMAP: Internet Message Access Protocol, a standard for managing mail messages and folders on remote servers. The current version is IMAP4. Compare to POP. LDH rule: The rule that DNS host names can only contain Letters, Digits, and Hyphens. Further rules forbid leading or trailing hyphens, and names with hyphens in the third and fourth positions. Legacy address: An email address that consists of only ASCII characters. Compare to an internationalized address. Legacy mail: Messages with only legacy addresses. Compare to EAI mail. Linkify and linkification: Automatically formatting text to add clickable links to HTML URLs in the text. Mail delivery agent (MDA): A server program that handles incoming mail and typically stores it in a mailbox or folder. Mail folder: A collection of messages with a name. A mailbox can contain multiple folders. Mail header: The collection of structured fields at the beginning of a mail message preceding the mail body. Each field starts with a field name and a colon, and consists of one or more lines. Mail submission agent (MSA): A server program that receives mail from a MUA and prepares it for transmission and delivery. UASG012: Email Address Internationalization (EAI): A Technical Overview  Mail transmission agent (MTA): A server program that sends and receives mail to and from other Internet hosts. An MTA may receive mail from an MSA and/or deliver mail to an MDA. Mail user agent (MUA): A client program that a person uses to send, receive, and manage mail. Popular MUAs include Outlook and Thunderbird. Mailbox: A place to store messages associated with a mail address. A mailbox may be a single folder or a collection of folders. Metadata: Information about a mail message, distinct from the message itself. Metadata may include the time the message was sent or received and whether the recipient has opened it. MIME: Multipurpose Internet Mail Extensions, a specification for encoding different kinds of data including non-ASCII text, and for including multiple logical parts in a single message. MX: Mail Exchanger, a DNS record that identifies a host that receives mail for a domain. Normalization: Transforming text into a standard representation, e.g., combining separate character and accent codepoints into precomposed codepoints. Normalization Form C (NFC): A profile of Unicode in which characters are precomposed. POP: Post Office Protocol, a standard for retrieving messages from a remote server. The current version is POP3. Compare to IMAP. Precomposed: A character that is represented as a single codepoint rather than as a separate base character and accents and other modifiers. PRECIS: Preparation and Comparison of Internationalized Strings, a set of IETF documents that set out principles for creating UTF-8 usernames and nicknames. Procmail: An MDA popular on Unix and Linux systems. Wikipedia article. Punycode: An ASCII encoding of UTF-8 used in ACE A-labels (RFC 3492). SASL: Simple Authentication and Security Layer, a set of IETF standards that define the username and password authentication schemes used to log into SUBMIT, IMAP, and POP servers. Script: A collection of codepoints used to write a language. Some languages such as English are written in a single script, others such as Japanese are written in multiple scripts. SIEVE: A language for filtering and sorting incoming mail messages (RFC 5228). SMTP: Simple Mail Transport Protocol, the way computers on the Internet exchange mail String preparation: Turning a UTF-8 string into a standard form to make it easier to process. SUBMIT or submission: transmitting a newly created message for relay and/or delivery (RFC 6409) U-label: A UTF-8 domain label. Compare to A-label. Variant characters: Characters in a script with the same meaning but different visual representations. UASG012: Email Address Internationalization (EAI): A Technical Overview // ==================== Universal Acceptance Compliance of Some Programming Language Libraries and Frameworks 14 September 2020 Report UASG018A TABLE OF CONTENTS Introduction 3 New Libraries and Frameworks 5 Methodology 6 Datasets 6 H_DNS 6 H_ES (to check EAI) 6 H_ID 6 L_A2U 6 L_U2A 6 Results 7 Discussion 8 C - Libcurl (EAI) 8 C - Libidn2 (IDNA2008) 9 C# - Mailkit (EAI) 9 C# - Microsoft - System.Globalization.IdnMapping (IDNA2008) 9 Go - Idna (IDNA2008) 9 Go - Mail (EAI) 9 Go - Smtp (EAI) 10 Java - commons-validators (EAI, IDNA2008) 10 Java - guava (IDNA2008) 10 Java - ICU (IDNA2008) 10 Java - Jakartamail (EAI) 10 Java - JRE - java.net.IDN (IDNA2008) 11 Javascript - idna-uts46 (IDNA2008) 11 Javascript - nodemailer (EAI) 11 Javascript - validator (EAI) 11 Python 3 - django auth (EAI) 11 Python 3 - email_validator (EAI) 12 Python 3 - encodings_idna (IDNA2008) 12 Python 3 - idna (IDNA2008) 12 Python 3 - smtplib (EAI) 12 Rust - idna (IDNA2008) 12 Rust - lettre (EAI) 13 Conclusion 13 Addendum: Appendix A: Requirements for the test data sets 14 Universal Acceptance Compliance of Some Programming Language Libraries and Frameworks - Report UASG018A - Page 2 Introduction This document describes the results of the second phase of the work done before. The results of the previous phase are available on the UASG site. This new phase expands the previous work by adding new languages and frameworks and also verifying the compliance of internationalized email (EAI). The first phase of the work verified the following languages and libraries for Universal Acceptance readiness: Language Framework/Library Java Commons Validator Java Guava Java ICU Java JRE Python3 Django_auth Python3 Encodings_Idna Python3 Idna Rust Idna These frameworks were essentially using domain names as their primary objects, so internationalized email was not tested. This document describes the results of verifying the following languages and frameworks, including the testing of internationalized email: Language Framework/Library C libcurl C libidn2 C# Mailkit C# Microsoft Go Idna Go Mail Go Smtp Java Commons-Validator Java Guava Universal Acceptance Compliance of Some Programming Language Libraries and Frameworks - Report UASG018A - Page 3 Java ICU Java Javamail/JakartaMail Java JRE Javascript Idna-uts46 Javascript Nodemailer Javascript Validator Python3 Django_auth Python3 Email_Validator Python3 Encodings_Idna Python3 Idna Python3 Smtplib Rust Idna Rust Lettre The same libraries and frameworks from the first phase were verified again to see if there are improvements or regressions against their newest versions. Additional libraries and frameworks for the same language were added mostly because the new ones support email addresses. In summary, most libraries and frameworks from previous phase were not improved for the purpose of universal acceptance. The following table list the new versions verified under this work. Language Framework/Library Previous Phase This phase Java Commons-validator 1.6 1.6 Java Guava 26 28 Java ICU 51.1 67.1 Java JRE 10 11 Python3 Django_auth 2.7 3.0.7 Python3 Encodings_idna 3.7 3.8 Universal Acceptance Compliance of Some Programming Language Libraries and Frameworks - Report UASG018A - Page 4 Python3 Idna 2.7 2.9 Rust Idna 0.1.4 0.2.0 New Libraries and Frameworks This work verifies compliance of 4 new languages and 14 new libraries and frameworks, as listed below. Language Library/Framework Version C libcurl 7.70.0 C libidn2 2.3.0 C# mailkit 2.7.0 C# microsoft (IdnMapping) .net core 3.1.301 Go idna 1.14.4 Go mail 1.14.4 Go smtp 1.14.4 Java Jakarta Mail 1.6.5 Js Idna-uts46 1.1.0 Js nodemailer 10.7.1 Js validator 13.1.1 Python3 email_validator 1.1.1 Python3 smtplib 3.8 Rust lettre 0.9.3 Universal Acceptance Compliance of Some Programming Language Libraries and Frameworks - Report UASG018A - Page 5 Mobile platforms languages and libraries will be tested in a follow-up work. Methodology In order to verify Universal Acceptance readiness, 5 datasets of sample internationalized domain names & email addresses were used. The next section gives a short description of each one. These datasets are described in detail in UASG004 and UASG018 For email address internationalization (EAI), a dummy SMTP server, based on the popular Mailhog SMTP server, was used to verify the support of the SMTPUTF8 SMTP option by the mailer libraries and frameworks. However, Mailhog does not support SMTPUTF8 so we used a fork that enhance it to support SMTPUTF8. This dummy server, running within a docker, simulates communication with a real SMTP server from the library/framework perspective and checks if it behaves as expected. Datasets H_DNS Performs a syntactic check on a domain name. Determines whether the name appears to be correctly formed. If any part of the name already appears to be in ASCII form (an A-label), verify it can be converted to Unicode. Ref. RFC5891, RFC1035, SAC053 H_ES (to check EAI) Performs a syntactic check on an email address. Determines whether the address appears to be correctly formed. Ref. RFC5891, RFC6531 H_ID Compares the identifier stored in the system against the one used to authenticate by the user. The test cases aim to validate proper handling of internationalized identifiers by applications. Ref. RFC8264 L_A2U Converts a domain name in ASCII to Unicode using the process described in RFC5891. If the domain name, or any constituent label, is already in Unicode or an ASCII label does not begin with the ACE prefix, the original label should not be altered. Ref. RFC5891 L_U2A Converts a domain name in Unicode to ASCII using the process described in RFC5891 for domain name lookup. If the domain name, or any constituent label, is already in ASCII, the ASCII should not be altered. Ref. RFC5891, UTS#46 Universal Acceptance Compliance of Some Programming Language Libraries and Frameworks - Report UASG018A - Page 6 Results Here is the complete list of libraries with their compliance with the corresponding dataset, with a color indicating if they are UA ready or not. Yellow color indicates that some edge cases are not supported or the library needs to be used along with another one to be compliant. Legend UA ready UA ready but developer needs to be careful UA not ready Language Lib Name Compliance on dataset (%) Datasets c libcurl 84.3 HEs c libidn2 95.2 LA2U ,LU2A csharp mailkit 84.3 HEs csharp microsoft 83.9 LA2U ,LU2A go idna 79 LA2U ,LU2A go mail 100 HEs go smtp 19.6 HEs java commons-validator 85.5 HEs ,HDns java guava 77.8 HDns Universal Acceptance Compliance of Some Programming Language Libraries and Frameworks - Report UASG018A - Page 7 java icu 93.5 LA2U ,LU2A java jakartamail 82.4 HEs java jre 71 LA2U ,LU2A js idna-uts46 85.5 LA2U ,LU2A js nodemailer 84.3 HEs js validator 94.2 HEs ,HDns python3 django_auth 48.1 HEs ,HId python3 email_validator 86.3 HEs python3 encodings_idna 67.7 LU2A ,LA2U python3 idna 100 LA2U ,LU2A python3 smtplib 84.3 HEs rust idna 87.1 LA2U ,LU2A rust lettre 7.8 HEs Discussion Detailed results are available at  C - Libcurl (EAI) UA ready but developer needs to be careful Even if libcurl sends properly the SMTPUTF8 flag, validations done by libcurl are insufficient: we were able to send email to multiple invalid addresses. Developers need to use another library to validate the address before sending it. Libcurl was chosen because it is by far the most popular and used library in C for sending & downloading content. Universal Acceptance Compliance of Some Programming Language Libraries and Frameworks - Report UASG018A - Page 8 C - Libidn2 (IDNA2008) UA Ready Supports well IDNA2008 as advertised. Libidn2 was chosen because it is the next generation of the well established Gnu Libidn (IDNA2003). C# - Mailkit (EAI) UA ready but developer needs to be careful Similar to libcurl, this library supports the STMPUTF8 flag, but multiple invalid email addresses were allowed. Mailkit was chosen because it is recommended by Microsoft over native C# SmtpClient, since the latter is deprecated by Microsoft: C# - Microsoft - System.Globalization.IdnMapping (IDNA2008) UA Ready Microsoft provides natively in the .NET framework utilities to convert A-label & U-label. It supports IDNA2008 as advertised. We found some false positives where the library converts domains known as unconvertable. Go - Idna (IDNA2008) UA ready but developer needs to be careful Go provides a library natively compatible with IDNA2008 as advertised. However, we found not only false positives, but also valid domains that net/idna was not able to convert. Go - Mail (EAI) UA ready but developer needs to be careful Go native mail validation/parsing/mailer package. This library is very good for validating and parsing EAI. However, it should not be used to send email since it is based on net/smtp which does not send SMTPUTF8. See next. Universal Acceptance Compliance of Some Programming Language Libraries and Frameworks - Report UASG018A - Page 9 Go - Smtp (EAI) UA not ready Go native mailer package. Does not support STMPUTF8 flag. Java - commons-validators (EAI, IDNA2008) UA not ready A popular Apache package to validate email addresses, domains and many other things. Since the validation is based on a static list of TLDs, it is not recommended to use as the static list is always not to date. No new version since February 2017. Java - guava (IDNA2008) UA not ready A popular utilities library from Google. As it is advertised: "validation against RFC 3490 ("Internationalizing Domain Names in Applications") is skipped" (IDNA2003). It supports many U-Label since "validation against RFC 1035 is relaxed", see "InternetDomainName.from(input)" method. Java - ICU (IDNA2008) UA Ready Library from the Unicode Consortium. Developers must use a combination of flags to correctly support IDNA2008. The following code show how to initialize the validator: IDNA validator = IDNA.getUTS46Instance( IDNA.NONTRANSITIONAL_TO_ASCII | IDNA.NONTRANSITIONAL_TO_UNICODE | IDNA.CHECK_BIDI | IDNA.CHECK_CONTEXTJ | IDNA.CHECK_CONTEXTO | IDNA.USE_STD3_RULES) Java - Jakartamail (EAI) UA Ready Native library (previously named Javamail) to send mail. Now under the stewardship of the Eclipse foundation. Supports correctly EAI since 1.6.4. Version 1.6.5 was verified. Since email address validation is made automatically before sending the email, this library is a good choice. Universal Acceptance Compliance of Some Programming Language Libraries and Frameworks - Report UASG018A - Page 10 Java - JRE - java.net.IDN (IDNA2008) UA not ready Native lib to convert U-label and A-label. Based on IDNA2003. Not recommended. Javascript - idna-uts46 (IDNA2008) UA ready but developer needs to be careful Converter for U-label and A-label. Despite its name, it is possible to configure the lib for IDNA2008 only (transitional = false). It doesn't implement Bidi and contextual rules for validation. This library seems the only one available for the task. Javascript - nodemailer (EAI) UA ready but developer needs to be careful Mailer for NodeJs. Supports SMTPUTF8 flag. Nodemailer doesn't validate email addresses thoroughly, therefore it must be used with an email validation library like "validator", see next. Javascript - validator (EAI) UA Ready Popular javascript package for various validation. Very good compliance on our dataset, can be used to validate & normalize email before sending email with nodemailer for instance. Python 3 - django auth (EAI) UA not ready Popular web package to manage authentication with emails. Non compliant over basic international email addresses. Maintainers seems to have rejected the following pull request that would have make the lib compliant (identified in UASG018):  e65c60 Here is an extract of the discussion made on the issue: Universal Acceptance Compliance of Some Programming Language Libraries and Frameworks - Report UASG018A - Page 11 "RFC 6531 does define a new SMTPUTF8 extension  to allow (notably) non-ASCII chars in email addresses. Usage seems to be very scarce however at this time. Allowing non-ASCII chars when 95% of mail servers do currently not seem to support that is debatable." - Claude Paroz  Python 3 - email_validator (EAI) UA Ready Popular lib to validate & normalize email addresses. Very good compliance over the dataset. Python 3 - encodings_idna (IDNA2008) UA not ready Native converter for U-label and A-label. Based on IDNA2003. Not recommended. Python 3 - idna (IDNA2008) UA Ready Very good IDNA2008 compliant library. The most compliant library with our dataset we tested until now. Compliant with IDNA2008 as advertised. Highly recommended. Python 3 - smtplib (EAI) UA ready but developer needs to be careful Native library for sending email. Supports SMTPUTF8 flag. Needs to be used with an email validation/normalization library like email_validator before sending the email. Rust - idna (IDNA2008) UA Ready Native library for conversion between U-label & A-label. Supports IDNA2008, good compliance on the datasets. Universal Acceptance Compliance of Some Programming Language Libraries and Frameworks - Report UASG018A - Page 12 Rust - lettre (EAI) UA not ready Native library for sending email. Since Lettre uses an EmailAddress object that works only with ASCII addresses, Lettre does not support EAI even if SMTUTF8 supports is advertised. See  Conclusion Many of the new tested libraries claim to support or support recently IDNA2008 and EAI. To name a few: • C - libcurl starts to support EAI this year at version 7.69.0 (we tested 7.70.0), see: • Java - jakarta mail (previously java mail) starts to stabilize the support at version 1.6.4 (last year, see bug fixes on UTF-8 handling  we tested v1.6.5. • C# - Microsoft IdnMapping was supporting IDNA2003 prior to Windows 8 et make the switch; • Python 3 - smtplib starts to support EAI at version of Python 3.5, we tested 3.8; Therefore, it is good to see progression towards Universal Acceptance. A useful feature for developers would be that SMTP client libraries validate and normalize the email address before sending it. We noticed that Jakarta Mail seems to be the only one to do both tasks. Some libs, like libcurl, transform the domain part to an A-label beforehand, but don't check the local part, nor normalize. Nevertheless, really good libs to validate and normalize are available. Dependencies were found to be troublesome. For example, Go net/mail rely on a smtp lib that doesn't support SMTPUTF8 even if net/mail is perfectly compliant with internationalization RFCs for parsing. Rust Lettre claims to send SMTPUTF8 flag but uses internally an EmailAddress object supporting only ASCII addresses. Detailed results of the tests are available at:  Universal Acceptance Compliance of Some Programming Language Libraries and Frameworks - Report UASG018A - Page 13 ============== Universal Acceptance Readiness Framework 6 April 2020 UA Readiness Framework - Report UASG026 TABLE OF CONTENTS Introduction Categories of Applications Components Web-based Application Considerations Native Application Gating Steps Modeling Applications Web-based Application Native Application Gating Approach Gating Considerations Web-Based Application Components Applications Expected Behaviors Accept Validate Process on Input Store Process on Output Display Tests AT: Accept Test VT: Validate Test P1T: Process on Input Test ST: Store test P2T: Process on Output Test DT: Display Test Proposed Approach Web-Based Application: CMS Sub-Category Summary References 3 3 3 4 4 4 5 5 5 6 6 7 7 8 8 9 9 9 9 9 9 9 9 9 9 9 10 10 10 11 11 11 UA Readiness Framework - Report UASG026  Introduction Universal Acceptance (UA) is about enabling the use of identifier technologies that were not present at the beginning of the Internet deployment, especially when it comes to internationalization. More specifically, and for the purpose of this document, we summarize UA as the conformance status of an application or service that supports the following features: ● ● ● ● Internationalized Domain Name (IDN) ○ Because some software expects a domain name to be in ASCII. Email Address Internationalization (EAI) ○ Because some software expects the local part (e.g. the string at the left of the “@” sign for left-to-right scripts) of an email address to be in ASCII. ○ Because some mail servers or services do not expect to receive emails with the local part of the email address in non-ASCII. Long top-level domain (TLD) strings ○ Because some software expects a TLD string to be no longer than three characters. Added/removed TLD strings ○ Because some software checks TLDs based on an out of date and static list of possible TLDs. Regarding TLD strings being added or removed, it is worth noting that contrary to some user beliefs, TLDs are often added or removed from the root zone, even on a daily basis. For example, during a 10 day period in November 2019, 7 TLDs were removed from the root. Identifying whether or not an application of any kind, on any platform, correctly supports UA can be complicated. The purpose of this paper is to define a scope and framework that will identify the issues facing the developer community so that they can work to fix them and increase UA readiness. Related work on UA is available at  Categories of Applications For the purpose of this study, applications are either web-based or native as described below. Web-based application ● The User Interface (UI) is in a browser. ● The browser is either standalone or embedded. Note that some applications seem native but in fact are displaying HTML pages using an embedded browser. An embedded browser may be in desktop applications, cars, wearables, consumer products, and more. Native application ● Either computer-based or on mobile platforms (mobile phone, tablets, etc.) ● Runs directly on an operating system (OS). ● Does not primarily use a browser or an embedded browser view. UA Readiness Framework - Report UASG026  Components An application is typically made up of various components. Each application category defined above has its own set of components. This work takes a deliberately simplified approach and will only concentrate on the major components of an application. It may mean that sometimes the model is not as accurate for some applications. Splitting the application into components enables the UA compliance work to be applied to various gates between components, as discussed later. Gates can be viewed as functional separations in the application. Web-based Application A web-based application is made up of the following components: ● Web browser: The browser is another application; however, it is an integral part of a web application delivery. Note that sometimes web browsers appear as embedded in a native application. ● Front-end: The front-end is the component that creates and enables code to be executed into the browser. It is responsible for creating HTML and allowing HTML, CSS, and Javascript code to be executed in the browser. ● Back-end: The back-end is the component running on a remote server which typically executes more complex tasks, as well as maintaining state and accessing a database. ● Database: The database is the component storing information on a remote server. A database may be managed by a typical SQL database engine or even just a file. ● Filesystem: The filesystem is the place where files are stored on the operating system (OS). ● External Service: Sometimes an application uses an external service to complement its core functionalities. A typical example of an external service is an authentication service provided internally to an enterprise or by a cloud service provider. Considerations ● ● ● ● Given the nature of current web-based applications, this model is simplified but it does present typical components used in software development and is sufficient for the purpose of this work. Modern web browsers offer local storage which is usually limited in size and capabilities, but could be used by application developers to store UA identifiers. In modern cloud based applications, the front-end and the back-end are typically stateless, so they can be deployed horizontally dynamically in multiple instances as load requires. Therefore, the front-end and the back-end typically do not involve application data storage. Most web sites are typically engineered as applications; therefore, we assume that for the purpose of this work, a web site is a web-based application. Thus, the proposed model may be applied to a web site. Native Application A native application is made of the following components: ● User Interface (UI): The visual interface that interacts with the user. This interface is responsible for collecting user input such as domain names or email addresses. ● Internal: The code processing the user’s input and providing the functions of the application. ● Database: The database is the component storing application information. A UA Readiness Framework - Report UASG026  ● ● database may be managed by a typical SQL database engine, or even just a file. The database may be local or remote. Filesystem: The filesystem is the place where files are stored on the operating system (OS). External Service: Sometimes an application uses an external service to complement its core functionalities. A typical example of an external service is an authentication service provided internally to an enterprise or by a cloud service provider. Gating Steps The UA community has defined the following steps within an application to process UA related identifiers: 1. Accept: how an application accepts the user input which consists of UA identifiers. 2. Validate: how an application validates the UA identifier. 3. Process: after validation, how an application processes the UA identifier. 4. Store: after processing, how an application stores the UA identifier. 5. Display: how an application displays the UA identifier. This work proposes the addition of a step between store and display in order to provide a full sequence of steps that can be used as gates to verify conformance. The new list is as follows: 1. Accept: how an application accepts the user input which consists of UA identifiers. 2. Validate: how an application validates the UA identifier. 3. Process: after validation, how an application processes the UA identifier. 4. Store: after processing, how an application stores the UA identifier. 5. Process: after storing, how an application processes the UA identifier, typically for displaying. 6. Display: how an application displays the UA identifier. It should be noted that for some applications, some steps or gates may not be relevant. For example, some applications may not store identifiers, therefore steps 4 and 5 would be irrelevant. Modeling Applications The two categories of applications are modeled based on their respective components and the gating steps. Tables below show Y when the component plays a role in the step, and M when the component may play a role. Web-Based Application Browser Frontend Accept Validate Y Y (only IDN in URL) M Process Store Process M (local storage) M Display Y M UA Readiness Framework - Report UASG026  Backend M M M Database Y Filesystem Y External service M M M M Native Application Accept UI Y Internal Validate Process Store M M M M Y Filesystem Y M Display Y Database External service Process M M M Gating Approach This work proposes a gating approach to verify UA conformance of an application. This gating approach is based on applying tests at the various steps, now named gates, on the various components. The following test categories are defined. Keyword Expansion AT Accept test VT Validate test P1T Process test on the input ST Store test P2T Process test on the output DT Display test The following figure shows the proposed gating approach. Each test category is applied at a different step of the application. UA Readiness Framework - Report UASG026  Gating Considerations Modern software architectures are complex with containers, micro services, multi-tier, caches at all levels, cloud services, etc. In fact, an application is a web of components that have complex interactions. Even developers involved in the project have difficulties pinpointing the issues because of the complexity. While steps (accept, validate, process, store, display) are defined, some may be aggregated together so that there is no separation between some of the steps. For example, validating and processing might take place together within the same method on the identifier object. This work proposes a model, but frontiers between components are often blurred. Modern software architectures often use a variety of cloud services from different cloud service providers. The code of the services themselves, and that of their components, is normally not exposed. Therefore, these services should be considered black boxes with no way to look into them; they can only be tested from the interface that they provide. Given their dominance in the software development market, they must be taken into account in verifying UA conformance. Examples of such services are third party identity/authentication/authorization services. For a software developer, it is easier to use Google, Facebook, Apple or other pre-existing user authentication services, as it enables the developer to focus on aspects which will differentiate the relevant service without having to incur time and cost in ‘reinventing the wheel’ for commonly occurring functions. It also provides a more seamless experience for the end-users. As domains or email addresses are often used as identifiers, or as backup identifiers, they become a significant part of UA conformance of an application when such applications uses these services. Email address are not only used as unique identifiers for users, but there are often backup emails used for restoring the account or resetting the password which also must support UA conformance. Web-Based Application Components This section lists some web-based application components with examples. This list is not exhaustive. Category Examples Type of Application Browser Chrome, Firefox, Edge, Safari, Opera, Brave, UC, 360, Sogou, Baidu, Tencent, QQ Component of web-based application Web server nginx, Apache, lighttpd, tomcat, IIS Backend component of web-based application TLS Certificates openssl, letsencrypt Backend component of web-based application Backend web framework/libraries Django/Python, Flask/Python, Spring/Java, Express/NodeJS, Ruby on Rails, Component of web-based application UA Readiness Framework - Report UASG026  Lumen/PHP, .Net, Laravel Frontend web framework/libraries Angular, React, Vue.js, Backbone, Ember Bootstrap Component of web-based application Applications This section list some applications, either web-based or native, that would be candidates for UA conformance testing. Email (webmail) Gmail, Xgenplus, Coremail, Hotmail/Outlook/Live, Yahoo, Datamail, Mailrelay Web-based application Email (native client (MUA, MSA)) Gmail, Outlook, Xgenplus, Foxmail Native Email (server (M*A) MSexchange,postfix, Dovecot, Xgenplus, courier Native Email (service provider) Gmail, Hotmail/Outlook/Live, Yahoo, datamail CoreMail, QQ mail; 163/126 mail; China Mobile 139.com Native Antispam (AS) Spamjadoo, Comodo, SpamAssassin, SpamTitan Native OS tools Curl, Wget, nslookup, Dig, Telnet, SSH, Host, Hostname, SCP, Ping, Tracert, PathPing Native CMS WordPress, Joomla, Drupal, Typo3, Discuz, Pageadmin Web-based application Social Media Web Apps Facebook, Twitter, Pinterest, Instagram, LinkedIn, WhatsApp, WeChat, Sina Weibo, QQ Web-based application Social Media Apps Facebook, Twitter, Pinterest, Instagram, LinkedIn, WhatsApp, WeChat, Sina Weibo, QQ Native E-Commerce Web Apps Amazon, Alibaba, Ebay Web-based application It is worth noting that the same application is often delivered in two flavors: a web-based and a native version. For example, Facebook is available as a web-based application and as a native mobile application. However, for the purpose of UA conformance, those should be considered separate and different since one may behave differently to the other regarding UA. Expected Behaviors This section describes the expected behavior of the applications at each gate. UA Readiness Framework - Report UASG026  Accept ● All forms possible: i.e. IDN – either U-Label or A-Label. Validate ● ● Normalize if non-ASCII Optionally: ○ Verify if valid IDN ○ Verify if label is too long (> 63 octets, A-label if IDN) ● Maybe (has pros and cons): ○ Verify if TLD is active Process on Input ● ● Does not truncate Does not inadvertently convert to ASCII. For example, converting ‘é’ to ‘e’. Store ● ● ● EAI: local part UTF8 IDN: either U-Label or A-Label Long/new TLD: as is; no truncation Process on Output Display ● ● Should display in UTF8 May also display IDN as A-label Tests This section lists the various high-level tests that can be applied at each gate. The various possible datasets are described in the UASG-004 document. AT: Accept Test ● ● ● EAI: verify if it accepts any UTF8 IDN: verify if it accepts any UTF8 Long/new TLD: verify if it accepts any TLD as long label VT: Validate Test ● ● ● ● Verify if it normalizes a non-normalized UTF8 label Verify if it validates a valid/non-valid domain name Verify if it validates a valid/non-valid IDN Verify if it validates a valid/non-valid long/new TLD P1T: Process on Input Test ● Verify that the input of the processing does not change the output, unless it normalizes the string. ST: Store test ● EAI: UA Readiness Framework - Report UASG026  ○ ○ ● ● Given good EAI input, verify that the database content for that input is correct: i.e. either identical or normalized version of the local part. The domain part, if IDN, could be either A-Label or U-Label form. Given bad EAI input, verify that the database content for that input is not saved. IDN: ○ Given good IDN input, verify that the database content is either A-Label or ULabel form. ○ Given bad IDN input, verify that the database content for that input is not saved. Long/new TLD strings: ○ Given long TLD string as input, verify that the database content is not truncated. ○ Given too long TLD string as input, verify that the database content for that input is not saved. ○ Given new TLD string as input, verify the database content contains the new TLD. P2T: Process on Output Test ● Given a good value in the database, verify that the value going to be displayed by the UI is correct: local part is UTF8, IDN is in U-Label format, long string TLD is not truncated, new TLD string is processed. DT: Display Test ● Given a good value in the database, verify that the displayed value by the UI is correct: local part is UTF8, IDN is in U-Label format, long string TLD is not truncated, new TLD (from the root) is shown, removed TLD (from the root) is not shown. Normalization Normalization is required since the same string can be represented by different codepoints. Unicode defines various normalization forms[UTR15]. In absence of specifics, developers may use Normalization Form C (NFC). Proposed Approach The proposed approach to verify UA compliance of an application is as follows: ● Identify the components used in the application. ● Verify the UA compliance of each component. ● Test the application for UA compliance, from an input/output perspective without looking “under the hood.” ● If tests results are negative, then investigate by applying the gating approach to the various interfaces of the components, as described before. It should be noted that a component may not be UA compliant, but that does not mean the whole application is not UA compliant. This is because the developers of the application may have added another layer above the base component to support UA. For example, as shown by testing Java libraries for UA compliance, the JAVA base JRE is not UA compliant as it supports IDNA2003. However, a developer may use and add a new library that supports UA, so the fact that an application is implemented in Java does not mean it is not UA compliant. UA Readiness Framework - Report UASG026  This framework is intended for testing software applications. It may not be applicable as is for some other use cases such as libraries or infrastructure components. SMS messaging is an example of an infrastructure that may carry internationalized identifiers, but does not necessarily apply directly with this framework. Web-Based Application: CMS Sub-Category The following is an application of the approach to the web-based application category of Content Management Systems (CMS). This is a non-comprehensive list of CMS, but provides the most popular ranked by various sites. The market leader is WordPress. These are all open-source. The code can be downloaded and installed on a server, or many can also be used on hosting services. Browser Frontend Backend Database Gates/test control points WordPress Any PHP PHP/Apache MySQL/MariaDB AT, VT, P1T, ST, P2T, DT Joomla Any PHP PHP/Apache MySQL/MariaDB AT, VT, P1T, ST, P2T, DT Drupal Any PHP PHP/Apache /nginx MySQL/MariaDB/ PostgreSQL/SQLite AT, VT, P1T, ST, P2T, DT Typo3 Any PHP PHP/Apache /nginx MySQL/MariaDB/ PostgreSQL/SQLite AT, VT, P1T, ST, P2T, DT One can see that these share the same architecture and same components. Same tests can be applied to all. Summary This work provides a framework for scoping UA conformance work on software applications. It defines two categories of application and a series of gates for testing the application against various tests. References [UASG]  [UASG-004] Use Cases for UA Readiness Evaluation, April 2017,  [UTR15] Unicode Normalization Forms, Unicode® Standard Annex #15,  UA Readiness Framework - Report UASG026  =================================== Universal Acceptance Readiness Framework 6 April 2020 UA Readiness Framework - Report UASG026 TABLE OF CONTENTS Introduction Categories of Applications Components Web-based Application Considerations Native Application Gating Steps Modeling Applications Web-based Application Native Application Gating Approach Gating Considerations Web-Based Application Components Applications Expected Behaviors Accept Validate Process on Input Store Process on Output Display Tests AT: Accept Test VT: Validate Test P1T: Process on Input Test ST: Store test P2T: Process on Output Test DT: Display Test Proposed Approach Web-Based Application: CMS Sub-Category Summary References 3 3 3 4 4 4 5 5 5 6 6 7 7 8 8 9 9 9 9 9 9 9 9 9 9 9 10 10 10 11 11 11 UA Readiness Framework - Report UASG026  Introduction Universal Acceptance (UA) is about enabling the use of identifier technologies that were not present at the beginning of the Internet deployment, especially when it comes to internationalization. More specifically, and for the purpose of this document, we summarize UA as the conformance status of an application or service that supports the following features: ● ● ● ● Internationalized Domain Name (IDN) ○ Because some software expects a domain name to be in ASCII. Email Address Internationalization (EAI) ○ Because some software expects the local part (e.g. the string at the left of the “@” sign for left-to-right scripts) of an email address to be in ASCII. ○ Because some mail servers or services do not expect to receive emails with the local part of the email address in non-ASCII. Long top-level domain (TLD) strings ○ Because some software expects a TLD string to be no longer than three characters. Added/removed TLD strings ○ Because some software checks TLDs based on an out of date and static list of possible TLDs. Regarding TLD strings being added or removed, it is worth noting that contrary to some user beliefs, TLDs are often added or removed from the root zone, even on a daily basis. For example, during a 10 day period in November 2019, 7 TLDs were removed from the root. Identifying whether or not an application of any kind, on any platform, correctly supports UA can be complicated. The purpose of this paper is to define a scope and framework that will identify the issues facing the developer community so that they can work to fix them and increase UA readiness. Related work on UA is available at  Categories of Applications For the purpose of this study, applications are either web-based or native as described below. Web-based application ● The User Interface (UI) is in a browser. ● The browser is either standalone or embedded. Note that some applications seem native but in fact are displaying HTML pages using an embedded browser. An embedded browser may be in desktop applications, cars, wearables, consumer products, and more. Native application ● Either computer-based or on mobile platforms (mobile phone, tablets, etc.) ● Runs directly on an operating system (OS). ● Does not primarily use a browser or an embedded browser view. UA Readiness Framework - Report UASG026  Components An application is typically made up of various components. Each application category defined above has its own set of components. This work takes a deliberately simplified approach and will only concentrate on the major components of an application. It may mean that sometimes the model is not as accurate for some applications. Splitting the application into components enables the UA compliance work to be applied to various gates between components, as discussed later. Gates can be viewed as functional separations in the application. Web-based Application A web-based application is made up of the following components: ● Web browser: The browser is another application; however, it is an integral part of a web application delivery. Note that sometimes web browsers appear as embedded in a native application. ● Front-end: The front-end is the component that creates and enables code to be executed into the browser. It is responsible for creating HTML and allowing HTML, CSS, and Javascript code to be executed in the browser. ● Back-end: The back-end is the component running on a remote server which typically executes more complex tasks, as well as maintaining state and accessing a database. ● Database: The database is the component storing information on a remote server. A database may be managed by a typical SQL database engine or even just a file. ● Filesystem: The filesystem is the place where files are stored on the operating system (OS). ● External Service: Sometimes an application uses an external service to complement its core functionalities. A typical example of an external service is an authentication service provided internally to an enterprise or by a cloud service provider. Considerations ● ● ● ● Given the nature of current web-based applications, this model is simplified but it does present typical components used in software development and is sufficient for the purpose of this work. Modern web browsers offer local storage which is usually limited in size and capabilities, but could be used by application developers to store UA identifiers. In modern cloud based applications, the front-end and the back-end are typically stateless, so they can be deployed horizontally dynamically in multiple instances as load requires. Therefore, the front-end and the back-end typically do not involve application data storage. Most web sites are typically engineered as applications; therefore, we assume that for the purpose of this work, a web site is a web-based application. Thus, the proposed model may be applied to a web site. Native Application A native application is made of the following components: ● User Interface (UI): The visual interface that interacts with the user. This interface is responsible for collecting user input such as domain names or email addresses. ● Internal: The code processing the user’s input and providing the functions of the application. ● Database: The database is the component storing application information. A UA Readiness Framework - Report UASG026  ● ● database may be managed by a typical SQL database engine, or even just a file. The database may be local or remote. Filesystem: The filesystem is the place where files are stored on the operating system (OS). External Service: Sometimes an application uses an external service to complement its core functionalities. A typical example of an external service is an authentication service provided internally to an enterprise or by a cloud service provider. Gating Steps The UA community has defined the following steps within an application to process UA related identifiers: 1. Accept: how an application accepts the user input which consists of UA identifiers. 2. Validate: how an application validates the UA identifier. 3. Process: after validation, how an application processes the UA identifier. 4. Store: after processing, how an application stores the UA identifier. 5. Display: how an application displays the UA identifier. This work proposes the addition of a step between store and display in order to provide a full sequence of steps that can be used as gates to verify conformance. The new list is as follows: 1. Accept: how an application accepts the user input which consists of UA identifiers. 2. Validate: how an application validates the UA identifier. 3. Process: after validation, how an application processes the UA identifier. 4. Store: after processing, how an application stores the UA identifier. 5. Process: after storing, how an application processes the UA identifier, typically for displaying. 6. Display: how an application displays the UA identifier. It should be noted that for some applications, some steps or gates may not be relevant. For example, some applications may not store identifiers, therefore steps 4 and 5 would be irrelevant. Modeling Applications The two categories of applications are modeled based on their respective components and the gating steps. Tables below show Y when the component plays a role in the step, and M when the component may play a role. Web-Based Application Browser Frontend Accept Validate Y (only IDN in URL) M Process Store Process M (local storage) M Display Y M UA Readiness Framework - Report UASG026  Backend M Database Y Filesystem Y External service M M M M Native Application Accept UI Y Internal Validate Process Store M M M M Y Filesystem Y M Display Y Database External service Process M M M Gating Approach This work proposes a gating approach to verify UA conformance of an application. This gating approach is based on applying tests at the various steps, now named gates, on the various components. The following test categories are defined. Keyword Expansion AT Accept test VT Validate test P1T Process test on the input ST Store test P2T Process test on the output DT Display test The following figure shows the proposed gating approach. Each test category is applied at a different step of the application. UA Readiness Framework - Report UASG026  Gating Considerations Modern software architectures are complex with containers, micro services, multi-tier, caches at all levels, cloud services, etc. In fact, an application is a web of components that have complex interactions. Even developers involved in the project have difficulties pinpointing the issues because of the complexity. While steps (accept, validate, process, store, display) are defined, some may be aggregated together so that there is no separation between some of the steps. For example, validating and processing might take place together within the same method on the identifier object. This work proposes a model, but frontiers between components are often blurred. Modern software architectures often use a variety of cloud services from different cloud service providers. The code of the services themselves, and that of their components, is normally not exposed. Therefore, these services should be considered black boxes with no way to look into them; they can only be tested from the interface that they provide. Given their dominance in the software development market, they must be taken into account in verifying UA conformance. Examples of such services are third party identity/authentication/authorization services. For a software developer, it is easier to use Google, Facebook, Apple or other pre-existing user authentication services, as it enables the developer to focus on aspects which will differentiate the relevant service without having to incur time and cost in ‘reinventing the wheel’ for commonly occurring functions. It also provides a more seamless experience for the end-users. As domains or email addresses are often used as identifiers, or as backup identifiers, they become a significant part of UA conformance of an application when such applications uses these services. Email address are not only used as unique identifiers for users, but there are often backup emails used for restoring the account or resetting the password which also must support UA conformance. Web-Based Application Components This section lists some web-based application components with examples. This list is not exhaustive. Category Examples Type of Application Browser Chrome, Firefox, Edge, Safari, Opera, Brave, UC, 360, Sogou, Baidu, Tencent, QQ Component of web-based application Web server nginx, Apache, lighttpd, tomcat, IIS Backend component of web-based application TLS Certificates openssl, letsencrypt Backend component of web-based application Backend web framework/libraries Django/Python, Flask/Python, Spring/Java, Express/NodeJS, Ruby on Rails, Component of web-based application UA Readiness Framework - Report UASG026  Lumen/PHP, .Net, Laravel Frontend web framework/libraries Angular, React, Vue.js, Backbone, Ember Bootstrap Component of web-based application Applications This section list some applications, either web-based or native, that would be candidates for UA conformance testing. Email (webmail) Gmail, Xgenplus, Coremail, Hotmail/Outlook/Live, Yahoo, Datamail, Mailrelay Web-based application Email (native client (MUA, MSA)) Gmail, Outlook, Xgenplus, Foxmail Native Email (server (M*A) MSexchange,postfix, Dovecot, Xgenplus, courier Native Email (service provider) Gmail, Hotmail/Outlook/Live, Yahoo, datamail CoreMail, QQ mail; 163/126 mail; China Mobile 139.com Native Antispam (AS) Spamjadoo, Comodo, SpamAssassin, SpamTitan Native OS tools Curl, Wget, nslookup, Dig, Telnet, SSH, Host, Hostname, SCP, Ping, Tracert, PathPing Native CMS WordPress, Joomla, Drupal, Typo3, Discuz, Pageadmin Web-based application Social Media Web Apps Facebook, Twitter, Pinterest, Instagram, LinkedIn, WhatsApp, WeChat, Sina Weibo, QQ Web-based application Social Media Apps Facebook, Twitter, Pinterest, Instagram, LinkedIn, WhatsApp, WeChat, Sina Weibo, QQ Native E-Commerce Web Apps Amazon, Alibaba, Ebay Web-based application It is worth noting that the same application is often delivered in two flavors: a web-based and a native version. For example, Facebook is available as a web-based application and as a native mobile application. However, for the purpose of UA conformance, those should be considered separate and different since one may behave differently to the other regarding UA. Expected Behaviors This section describes the expected behavior of the applications at each gate. UA Readiness Framework - Report UASG026  Accept ● All forms possible: i.e. IDN – either U-Label or A-Label. Validate ● ● Normalize if non-ASCII Optionally: ○ Verify if valid IDN ○ Verify if label is too long (> 63 octets, A-label if IDN) ● Maybe (has pros and cons): ○ Verify if TLD is active Process on Input ● ● Does not truncate Does not inadvertently convert to ASCII. For example, converting ‘é’ to ‘e’. Store ● ● ● EAI: local part UTF8 IDN: either U-Label or A-Label Long/new TLD: as is; no truncation Process on Output Display ● ● Should display in UTF8 May also display IDN as A-label Tests This section lists the various high-level tests that can be applied at each gate. The various possible datasets are described in the UASG-004 document. AT: Accept Test ● ● ● EAI: verify if it accepts any UTF8 IDN: verify if it accepts any UTF8 Long/new TLD: verify if it accepts any TLD as long label VT: Validate Test ● ● ● ● Verify if it normalizes a non-normalized UTF8 label Verify if it validates a valid/non-valid domain name Verify if it validates a valid/non-valid IDN Verify if it validates a valid/non-valid long/new TLD P1T: Process on Input Test ● Verify that the input of the processing does not change the output, unless it normalizes the string. ST: Store test ● EAI: UA Readiness Framework - Report UASG026  ○ ○ ● ● Given good EAI input, verify that the database content for that input is correct: i.e. either identical or normalized version of the local part. The domain part, if IDN, could be either A-Label or U-Label form. Given bad EAI input, verify that the database content for that input is not saved. IDN: ○ Given good IDN input, verify that the database content is either A-Label or ULabel form. ○ Given bad IDN input, verify that the database content for that input is not saved. Long/new TLD strings: ○ Given long TLD string as input, verify that the database content is not truncated. ○ Given too long TLD string as input, verify that the database content for that input is not saved. ○ Given new TLD string as input, verify the database content contains the new TLD. P2T: Process on Output Test ● Given a good value in the database, verify that the value going to be displayed by the UI is correct: local part is UTF8, IDN is in U-Label format, long string TLD is not truncated, new TLD string is processed. DT: Display Test ● Given a good value in the database, verify that the displayed value by the UI is correct: local part is UTF8, IDN is in U-Label format, long string TLD is not truncated, new TLD (from the root) is shown, removed TLD (from the root) is not shown. Normalization Normalization is required since the same string can be represented by different codepoints. Unicode defines various normalization forms[UTR15]. In absence of specifics, developers may use Normalization Form C (NFC). Proposed Approach The proposed approach to verify UA compliance of an application is as follows: ● Identify the components used in the application. ● Verify the UA compliance of each component. ● Test the application for UA compliance, from an input/output perspective without looking “under the hood.” ● If tests results are negative, then investigate by applying the gating approach to the various interfaces of the components, as described before. It should be noted that a component may not be UA compliant, but that does not mean the whole application is not UA compliant. This is because the developers of the application may have added another layer above the base component to support UA. For example, as shown by testing Java libraries for UA compliance, the JAVA base JRE is not UA compliant as it supports IDNA2003. However, a developer may use and add a new library that supports UA, so the fact that an application is implemented in Java does not mean it is not UA compliant. UA Readiness Framework - Report UASG026  This framework is intended for testing software applications. It may not be applicable as is for some other use cases such as libraries or infrastructure components. SMS messaging is an example of an infrastructure that may carry internationalized identifiers, but does not necessarily apply directly with this framework. Web-Based Application: CMS Sub-Category The following is an application of the approach to the web-based application category of Content Management Systems (CMS). This is a non-comprehensive list of CMS, but provides the most popular ranked by various sites. The market leader is WordPress. These are all open-source. The code can be downloaded and installed on a server, or many can also be used on hosting services. Browser Frontend Backend Database Gates/test control points WordPress Any PHP PHP/Apache MySQL/MariaDB AT, VT, P1T, ST, P2T, DT Joomla Any PHP PHP/Apache MySQL/MariaDB AT, VT, P1T, ST, P2T, DT Drupal Any PHP PHP/Apache /nginx MySQL/MariaDB/ PostgreSQL/SQLite AT, VT, P1T, ST, P2T, DT Typo3 Any PHP PHP/Apache /nginx MySQL/MariaDB/ PostgreSQL/SQLite AT, VT, P1T, ST, P2T, DT One can see that these share the same architecture and same components. Same tests can be applied to all. Summary This work provides a framework for scoping UA conformance work on software applications. It defines two categories of application and a series of gates for testing the application against various tests. References [UASG]  [UASG-004] Use Cases for UA Readiness Evaluation, April 2017,  [UTR15] Unicode Normalization Forms, Unicode® Standard Annex #15,  UA Readiness Framework - Report UASG026  Considerations for Naming Internationalized Email Mailboxes 2 November 2020 Report UASG028 Table of Contents 3 4 5 Introduction Executive Summary Policy Topics for Consideration Supported Scripts Length of a Mailbox Name String Script Mixing Preventing Invalid Strings and Unstable-rendered Strings Right-to-Left (RTL) Script Consideration Aliases and Display Names Consideration Signs and Symbols Unicode Character Normalization Equivalence Considerations Other Considerations Glossary Considerations for Naming Internationalized Email Mailboxes - Report UASG028 5 5 6 8 9 11 12 12 13 15 16 Page 2 Introduction This document lays out considerations for naming internationalized mailboxes and is intended for administrators of email systems. Email standards RFC6533 Internationalized Delivery Status and Disposition Notifications and RFC6430 Email Feedback Report Type Value: not-spam now allow both mailbox names (the part of an email address before the ‘@’ sign) and domain names (the part after the ‘@’ sign) to use almost any language or writing system; they are no longer restricted to the letters A-Z and numbers 0-9. This is an important improvement for users who use and prefer languages other than English, and for the people with whom they exchange messages. However, system administrators need to adopt policies on mailbox names in order to maximize the benefits of having a greater choice of allowable characters, while limiting confusion, error, and opportunities for malice. This document is intended for administrators of email systems that wish to provision internationalized mailboxes for their users and/or configure and manage systems compatible with internationalized email addresses. It will help administrators ask the right questions and make good choices when setting their policy. In this document, familiarity with email systems and experience with Phase 1 of Email Address Internationalization (EAI) – the ability to send emails to and receive emails from internationalized addresses – is assumed. This document addresses issues in Phase 2 of EAI, such as naming and hosting internationalized mailboxes. The Glossary section provides definitions of specialized terms and acronyms used in this report. Considerations for Naming Internationalized Email Mailboxes - Report UASG028 Page 3 Executive Summary This document is intended for email administrators, systems administrators, and IT managers. Its purpose is to aggregate and specify the main operational and policy considerations to be considered when creating internationalized email address mailbox names, aliases, and display names. Mailbox names – the part of the email address before the ‘@’ symbol – are important as to how useful, user-friendly, and secure an email system will be, therefore it’s important for email administrators to adopt good policies for naming mailboxes. Historically, email addresses have been limited to Latin-script letters and digits, but now email technology has evolved to allow for both mailbox names and domain names to be written in almost any language and script. This flexibility makes policy choices more complex, and this document aims to guide email administrators in adapting mailbox name policy to cover email addresses outside of Latin-script letters and digits. Ultimately, the business purpose of email systems, along with the language needs of users and their correspondents, will decide policy choices and determine what scripts (writing systems for languages) will be allowed in mailbox names and their length. Since some spellings, character combinations, signs, or symbols are confusing or deceptive, the policy used by administrators should forbid them (details depend on the language used for the mailbox name). Technical issues about how names that look the same to users but might actually consist of different characters require special attention. Right-to-left (RTL) scripts have unique possibilities for confusing name spellings, so if your system allows these scripts there are additional policy topics that should be addressed. Users may exchange emails with people who experience difficulty reading the particular script used in an email address. To reduce these difficulties, implementing a policy that allows users to choose display names (the personal name displayed) and use aliases (alternate addresses for the same user) is recommended. This document also includes resources and references that provide more detail on several of these policy topics. It also includes a glossary of terms, some of which may be new to administrators when adopting multiple scripts and languages for mailbox names. Considerations for Naming Internationalized Email Mailboxes - Report UASG028 Page 4 Policy Topics for Consideration This document considers topics that might be included in a mailbox naming policy. Each section deals with one of these topics as follows: Description of topic. Explanation of considerations regarding the context of email systems, the user base, and user base needs. Policy recommendations (in some cases). Check list of actions that should be taken. Supported Scripts When setting up an email system, email administrators need to decide which scripts will be the default scripts of the system. The term “script” is used in the linguistic sense and is defined as: the conventions and sets of characters used together to write one or more languages. For instance, the Latin script is the set of letters A-Z and other characters commonly used to write English, French, and many other languages in Europe, North and South America, and Africa. The Arabic script is used to write many languages in the Middle East, North Africa, and South Asia. Considerations: Most systems will include ASCII code points for backward compatibility. EAI allows administrators to use additional scripts. Checklist [ ] Research the expectations of your users and the target market to understand the writing systems needed for both the mailbox name and domain name portion of an email address. [ ] Review this document to understand the complexities involved in providing additional scripts (e.g. possible confusion, errors, and opportunities for malice) and any potential impact on your users. [ ] Based on the expectations of your users, make a list of the allowable mailbox name scripts. Length of a Mailbox Name String Consider the length of the mailbox name in characters. What are the minimum and maximum lengths you want to permit? Considerations: There may be system constraints on the mailbox name string. Although email standards allow up to 64 octets in a mailbox name, some systems limit the string to less than the standard character limit. There can be user benefits to short names as they may be easier to remember and write. There can also be user benefits to long names as they can be more specific and are less likely to conflict with other mailbox names. You may already have a policy requiring mailbox names to be based on the personal name of the user, for instance, personal name and family name separated by a “.”. Considerations for Naming Internationalized Email Mailboxes - Report UASG028 Page 5 Consider keeping your existing policy but expanding it to a wider range of characters and languages. Also, consider what languages and characters your users and their correspondents are likely to be able to understand, remember, and enter into email address fields. When using UTF8 to add more languages and scripts, a single character can be represented in multiple octets which will increase the mailbox character length. For example, a mailbox name that consists of ASCII letters that requires 20 octets can be expanded to 60 octets when representing 20 letters in another language or script. Recommendations: None. Checklist: [ ] Know the constraints of your system. [ ] Understand the expectations of your users related to internationalized mailbox names. [ ] Consider applying the same or a similar policy on length to internationalized mailbox names as to legacy mailbox names. Script Mixing Script mixing refers to the use of characters from multiple scripts in a single mailbox name in a way that is not used in normal writing. In particular, some characters from other scripts might be confusingly similar to characters from the primary script, which opens possibilities for malice or confusion. Considerations: Script mixing leads to security issues and user confusion. For example, the below image shows several different but similar-looking Unicode code points that might lead to user confusion1. 1 Source :  Considerations for Naming Internationalized Email Mailboxes - Report UASG028 Page 6 Your correspondents will be writing the mailbox name and domain name together as an email address. If the domain name is in a certain script, it is natural for the mailbox name to be in the same script. Consider if any other script might be used with the domain name’s script. Some combinations might be necessary, while others can be confusing or perhaps malicious. Some cultures use multiple scripts for ordinary writing. For instance, most of the Japanese text is a mixture of characters from the Kanji, Hiragana, Katakana, and Latin (“Roman”) scripts. However, it is unusual to see Arabic script in Japanese texts. Latin-script mailbox names are typically case-insensitive. Upper-case and lower-case letters are treated as equivalent. For the scripts you use, consider if there are other equivalencies your users expect. For clarity, we do not generally consider mixtures of upper and lower-cases to be script mixing; see the Equivalence Considerations section for more detail. Within the Domain Name System (DNS), Internationalized Domain Names (IDNs) can be represented by two formats: U-label and A-label. In this document, A-label usage is not considered to be script mixing; see the Aliases Consideration section for more detail. Recommendations: For the best usability, it’s recommended that the mailbox name use the same script as the domain name portion of the email address, unless otherwise required to achieve your organization’s goals. Avoid the mixing of languages using the same script in the mailbox name to avoid using or creating visually similar mailbox name characters that are using different code points. Only characters that are used together in the ordinary writing of a language should be allowed in a given mailbox name in that language. Within the mailbox names, script mixing should be prohibited. For example, an Arabic mailbox might be limited to just Arabic characters, while a Japanese mailbox name might be permitted to include Kanji, Hiragana, Katakana, and Latin characters. Sample 1: Arabic script email address: ‫السعودية‬.‫مستخدم@رسيل‬ Sample 2: Japanese script email address with script mixing: Checklist: [ ] Consider the possible confusion, errors, and opportunities for malice due to script mixing both within the mailbox name and between the mailbox name and the domain name. [ ] Allow limited script mixing where there is a clear user need based on local practice and market requirements. For example, users of a retail email service may demand names with certain kinds of script mixing, while members of an organization may have fewer objections to a limited choice of mailbox names that exclude that script mixing. [ ] If users are allowed to request their mailbox names, provide examples for users. Considerations for Naming Internationalized Email Mailboxes - Report UASG028 Page 7 Preventing Invalid Strings and Unstable-Rendered Strings In some writing systems, characters can be combined in valid ways allowing productive communication, but also in invalid ways leading to confusion and security risks. Such strings of characters will not be rendered consistently between platforms and applications – they will look different on different systems or displays. This topic addresses ways to avoid invalid strings. Considerations: The DNS has defined clear rules for which characters can be used and which should be avoided for both languages and scripts. For some scripts, particularly Southeast Asian and South Asian scripts, characters and marks can be combined on multiple levels. For example, consider the Thai script strings “ดี”ี vs “ดี”. The first one, “ดี”ี U+0E14(ด) + U+0E35 ( ีี)+ U+0E35 ( ีี) is invalid because it looks like ดี U+0E14(ด) + U+0E35 ( ีี). The Thai script user community has identified a rule that U+0E35 cannot follow U+0E35. These rules used in the DNS are known as Label Generation Rules (LGRs). You might want to adopt these rules for the mailboxes on your system. However, the LGRs might be more restrictive than necessary to be on your system. For instance, the Root Zone LGRs forbid using digits, but digits may be fine to use in your mailbox names. Some scripts do not yet have LGRs, so you cannot use them as a reference. You can refer to the existing Second Level Reference LGRs to validate the mailbox names, and an LGR validation tool is available online at  The source code for the tool is also available on GitHub which you can download and integrate into your system. Recommendations: Avoid potential security issues caused by creating mailbox names using invalid strings and its equivalents. If you intend to offer mailbox names in one language, refer to the language-based LGR. For example, if you want to offer mailbox names in German then use the German language LGR. If you intend to offer mailbox names in one script which may cover multiple languages, refer to the script-based LGR. For example, if you want to offer mailbox names in German, French, and Swedish then use the appropriate subset of the Latin script LGR. For scripts not covered by the Second Level Reference LGRs, you can refer to the Root Zone LGRs or follow high-level principles in RFC6912. For rules on digits in names using right-to-left scripts, check the Right-to-Left Scripts for Internationalized Domain Names for Applications (IDNA) RFC5893. Checklist: [ ] Determine if the Second Level Reference LGR meets your desired mailbox name string requirements. If it does, adopt the reference LGR. If it does not exactly meet your requirements, update it as needed. [ ] Share the Label Generation Rules (LGRs) as a mechanism to allow your end users to understand which characters and combinations will be considered valid. Considerations for Naming Internationalized Email Mailboxes - Report UASG028 Page 8 [ ] If applicable, use the LGR validation tool to manually validate the mailbox strings. [ ] Consider if you want to use the LGR validation tool as-is, or if you want to deploy it on an internal server to streamline your workflow and to keep the mailbox names it processes inside your network. Right-to-Left (RTL) Script Consideration Arabic, Hebrew, Persian, and Urdu are current widespread right-to-left writing systems. Over time, as the usage of the Arabic script spread, the repertoire of 28 characters used to write the Arabic language was supplemented to accommodate the sounds of many other languages such as Pashto, Persian, Urdu, etc. While the Hebrew alphabet is used to write the Hebrew language, it is also used to write other languages such as Yiddish. In a right-to-left (RTL), top-to-bottom script, writing starts from the right of the page and continues to the left. This can be contrasted against left-to-right (LTR) writing systems, where writing starts from the left of the page and continues to the right. Note, however, that within a right-to-left script, some text may be written left-to-right. For instance, in Arabic, numbers and words in Latin script are written left-to-right. Thus, these scripts are sometimes referred to as "bidirectional". Considerations: Right-to-left scripts have potential for confusion that left-to-right scripts do not. The Label Generation Rules (LGRs) for these scripts reflect careful consideration of these possibilities. Take what the LGRs require or forbid seriously as there may be good but not obvious reasons for it. When exchanging email between a right-to-left address and people who do not read right-to-left script, it is even harder to be sure the address is understood. The use of alias names may be especially helpful. See the section, Aliases and Display Names Consideration for more. Some right-to-left scripts (e.g., Arabic and Hebrew) can have the “same” labels with more than one representation. These alternatives lend themselves to being treated as equivalents to an email address, rather than independent addresses. See the section, Equivalence Considerations for more details. It is common for text in a right-to-left context to be bidirectional. For example, Latinscript words (e.g., "Cola") and Arabic numerals (e.g., 123) will be written left-to-right. Also, some punctuation takes on the directionality of surrounding text. This means that mailbox names that include left-to-right components may be more likely to be mistyped. Arabic script uses its own numerals in addition to ASCII numerals. If a mailbox name includes a number, consider the type of number to use and whether the name using the other kind of number should be treated as an "equivalent". Script mixing concerns apply for names that have both kinds of digits. With bidirectional text, it can be visually unclear what the order of characters is. Usually, text is entered and stored in the same order that it is spoken, but this may not have a simple correspondence to the right-to-left position of the text in the displayed address. This is generally not a problem for someone who can read the script and understand when the direction changes. However, those who cannot read the script may have difficulty determining keypress order from the address as displayed. Considerations for Naming Internationalized Email Mailboxes - Report UASG028 Page 9 Local keyboards are adapted to the local script and may not conveniently include all characters used in email addresses. Some keyboards do not include keys for period ('.') or at-sign ('@'). This makes email addresses more difficult to type. Consider the type of keyboard that will be used to type in your mailbox names, and whether to allow characters that are harder to type. Many right-to-left scripts include diacritics for representing vowels and pronunciation. These are essentially optional. If a mailbox name allows these diacritics, users may forget to include them. It is simpler to allow names without these diacritics. Arabic script, which usually displays characters joined together in calligraphy, has optional characters to force or prevent joining between characters. These are known as "zero width joiner" and "zero width non-joiner". They are a lesser-known mechanism – an artifact of computer-encoded text – so many users may not know how to use them. Mailbox names that rely on joiners may be more difficult for users to type correctly. Recommendations: It's not recommended to use combining marks especially in Arabic script. For example, use ‫ محمد‬instead of ٌ‫ح َّمد‬ َ ‫ ُم‬and ٌ‫ٌشؤون‬instead of ٌ‫ شُؤون‬. Mailbox names that use right-to-left scripts should not begin with a digit. Digits at the start of a text may be placed confusingly by the text direction rules. Avoid potential security issues caused by invalid strings and their “equivalents”. Invalid strings and equivalents are particularly common for Arabic script. See the Preventing Invalid Strings and Unstable-Rendered Strings section above and the Equivalence Considerations section below. If you intend to offer mailbox names in one language, refer to the language-based LGR. For example, if you want to offer mailbox names in Arabic then use the Arabic language LGRs. Check the Equivalence Considerations section for details. If you intend to offer mailbox names in one script that may cover multiple languages, refer to the script-based LGR. For example, if you want to offer mailbox names in Arabic, Pashto, and Urdu, then use the Arabic script LGR. For the scripts not covered by the Second Level Reference LGRs, refer to the Root Zone LGRs or follow high-level principles in RFC6912. For rules on digits in mailbox names using right-to-left scripts, check RFC5893 which provides the needed guidance on the use of right-to-left scripts for Internationalized Domain Names for Applications (IDNA). Checklist: [ ] Avoid script mixing with right-to-left scripts as it can lead to confusability and security issues. [ ] Use Second Level Reference LRGs or Root Zone LGRs. [ ] Avoid allowing two mailboxes with mailbox names that are equivalent to each other. Considerations for Naming Internationalized Email Mailboxes - Report UASG028 Page 10 Aliases and Display Names Consideration Some email systems make it easy for users to have multiple email mailbox names or multiple display names directing mail to and from the same mailbox. These aliases and display names serve many purposes and can be used for several EAI use cases. Use cases include: Users requiring multiple script email addresses, such as a bilingual business card in both the native script and Latin script. Working around incompatible systems when sending or receiving emails. Making it easier for senders to recognize the email address and aliases in their address book. Considerations: Assess the email delivery paths from your users to their correspondents and from their correspondents back to your users. Be aware that mail delivered in these two directions might encounter different systems, so one direction might work well and the other might have problems. The more varied the correspondents and the wider variety of delivery paths for emails to and from your system, the more likely you are to encounter a delivery system that fails to deliver mail to or from internationalized email addresses. Allowing aliases or display names that are in a different script than the mailbox name might create security issues; however, it could also be beneficial when the EAI address is used across different language communities. Below is an example of Arabic display name for an English email address: "‫مصر‬.‫سجل‬-‫< "مشرف@اختبار‬adminmail@datamail.asia> Display name Email address Recommendations: Consider providing an ASCII email address as an alias for your internationalized email addresses. The alias should deliver emails to the same location as the internationalized address. The user should be able to choose whether to send a message or a reply from the internationalized address or from the ASCII alias address. Checklist: [ ] Understand if your system supports aliases. [ ] If your system supports aliases, add an alias-creation option to the user interface during the mailbox name selection process. The user will be informed that they should have an ASCII alias and be allowed to create one associated with their EAI mailbox name. [ ] You may optionally add a user interface allowing the user to add additional aliases at a later time, if your system supports this. [ ] If you assign mailbox names to users rather than allowing them to select mailboxes themselves, then assign the ASCII alias at the same time as you assign the EAI mailbox name. Considerations for Naming Internationalized Email Mailboxes - Report UASG028 Page 11 Signs and Symbols Some signs and symbols are allowed in ASCII mailbox names, for example, (.) dot, underscore (_), hyphen (-), and plus sign (+). When deciding or selecting an EAI mailbox name(s) the administrator also needs to consider what Unicode signs or symbols should be allowed for use in the scripts being supported. Considerations: The inclusion principle (refer to LGR procedure) should be considered. The inclusion principle advises to only include the set of characters, e.g., signs and symbols, that are needed by the users, starting from an empty list. Symbols that create security issues specific to your implementation should be avoided. Only allow signs and symbols that are feasible for your users and their correspondents to read and input. The mailbox name should be typeable by commonly used Input Method Editors (IMEs). Set a policy that relates and have similar limitations considered for the Latin mailbox name as the internationalized mailbox name in a consistent and understandable way. Recommendations: Avoid mathematical marks that could create security issues, e.g., # $ % = “ * <, >. Emoji should not be allowed (reference to ICANN’s SSAC Advisory SAC95). The combining marks that fail the type-able principle should be disallowed, e.g., Arabic Hamza Above (U+0654). Checklist: [ ] By default, avoid using mathematical marks. [ ] By default, avoid using any signs and symbols that do not exist in your user’s keyboard/input devices. Some signs and symbols are not available in input devices for specific markets. [ ] Understand your users and local market expectations. If signs and symbols are required for your market, the dot (.), underscore (_), hyphen (-) and plus sign (+) are commonly used and could be added to the repertoire. [ ] Review the use of additional signs (if needed) and ensure it does not cause a security issue for the end users, including customer confusion, cross-scripting, and other security issues. Unicode Character Normalization The Unicode standard defines a text normalization procedure that replaces equivalent sequences of characters so that any two texts that are equivalent will be reduced to the same sequence of code points. Unicode defines normalized forms of a characters that can be encoded in multiple ways as there are various types of standardized forms, e.g., Normalization Form D (NFD) and Normalization Form C (NFC). Considerations for Naming Internationalized Email Mailboxes - Report UASG028 Page 12 Example: Å can be encoded by 212B or 00C5. Both should refer to the same mailbox, not to different mailboxes, and would be normalized to the same NFD and NFC. Note that although these examples use Latin characters, similar examples are found in other scripts. More details on the other types of normalization, with samples, can be found on the Unicode consortium website. Recommendations Mailbox names should use NFC for consistency with domain names, and also because NFC strings, in most cases, are shorter than NFD strings. Typically, standard software already encodes Unicode normalization in their libraries. Email administrators should know the normalization type of the system they operate in order to be able to assign and manage its mailboxes. Domain names use Normalization Form C (NFC). When building a system, ensure that the libraries support NFC for consistency. Checklist [ ] Get to know the normalization type of your email system. [ ] Ensure that your email program does normalized-form-independent name comparisons. [ ] If it’s possible to select normalization type, select NFC unless there is motivation to use other forms. Equivalence Considerations When domain name labels are considered the “same” or “interchangeable” by the community, they are called “variant” domain name labels. When email mailbox strings are considered the “same” by the community, this document refers to them as “equivalent” mailbox names. Sometimes equivalent names are useful and can be used as aliases for the primary mailbox name. In other cases, they are confusing and may lead to security issues if not identified or assigned to a different user. Considerations: In ASCII email addresses, some mail services may consider upper-case and lowercase letters as equivalent. The DNS community has done a great deal of work to define clear Label Generation Rules (LGRs), including identification of variant labels in different scripts. Consult the LGRs to see if you want to use them as the basis of your definition of mailbox name equivalent. Examples: 1. Traditional Chinese and Simplified Chinese equivalents: 名称 which means “name” (U+540D U+79F0) Considerations for Naming Internationalized Email Mailboxes - Report UASG028 Page 13 名稱 which means “name” (U+540D U+7A31) 名称 (Míngchēng, means “Name”) is used in China mainland and 名稱 (Míngchēng, means “Name”) is used in Taiwan and Hongkong, however, all of the Chinese community could recognize these two words as the same. 2. Arabic script equivalents (the word means “network” in Arabic): ‫( شبکۃ‬Unicode U+06C3 U+06A9 U+0628 U+0634) ‫( شبکة‬Unicode U+0629 U+06A9 U+0628 U+0634) ‫( شبكة‬Unicode U+0629 U+0643 U+0628 U+0634) 3. Full width versus half-width characters in Japanese and Chinese scripts. “JＩM” vs “JIM”, “１２３” vs “123”, “アイオ” vs “ｱｲｵ”. 4. Case folding equivalents: John.Callen john.callen John.callen john.Callen 5. Variation of name and separator (may also be considered equivalent): john.callen johncallen For an email system, you might consider delivering any emails addressed to the equivalent mailbox names to the same mailbox. This avoids customer confusion, cross-scripting, and other security issues. Additional equivalents can be assigned to the same mailbox as aliases, but these can get very numerous (hundreds or thousands) and become a management challenge. So, make the trade-off between the usefulness and the overhead of equivalents with caution. Note that variants in the domain name portion of the email address may have similar user impact. The discussion of domain names and their variants is outside of the scope of this document Be aware of the kinds of errors or confusion that may occur when users type in email addresses for your system. This document covers confusion in the mailbox name part of the address. There may also be confusion about the correct spelling or normalization of the domain name part of the address. Domain name variants are outside of the scope of this document. Recommendations: After a mailbox name has been assigned, the equivalent of that mailbox name should be identified and marked as registered and withheld from registration to a different user. Consider treating the most useful equivalents of a mailbox name as aliases (see Aliases Consideration section of this document), and deliver emails addressed to the equivalent mailbox to the same location as the original mailbox name. However, its Considerations for Naming Internationalized Email Mailboxes - Report UASG028 Page 14 management might be difficult, so make the trade-off between its usefulness and the overhead of handling equivalents with caution, and on an as-needed basis. Consider practical, language-based equivalent rules for an equivalent mailbox. For example, with ASCII mailbox names, treating all upper and lower-case variations as equivalent is practical. With a Simplified Chinese mailbox name like 中国 which means “China”, consider treating the Traditional Chinese name with the same meaning, 中國, as an equivalent. All case folding permutations should be considered as the same mailbox. When there is more than one digit set being used in the same repertoire (set of possible codepoints used to create mailbox names), those digits should be mapped as equivalent codepoints. For example, a Hindi mailbox administrator may consider abc123 and abc१२३ as equivalent mailbox names: Mailbox name: abc123 Equivalent mailbox name: abc१२३ Checklist: [ ] Define a policy for determining the “same” or equivalent mailbox names that will apply to your system based on the writing system, user expectations, and technical capabilities of your implementation. Your policy will need to examine the LGR, case-folding, separators, numerals, and symbols in the considerations section above. [ ] Determine if the Second Level Reference LGR meets your desired mailbox name string equivalence requirements. If it does not meet your requirements, adapt it as needed. [ ] Share your policy to let end users understand which characters and combinations will be considered valid and which ones might have equivalence. [ ] When using equivalent strings, consider if you want to use the validation tool as is or if you want to deploy it on an internal server to streamline your workflow and to keep the mailbox names it processes inside your network. Other Considerations The internationalized domain name part of an email address can be spelled with Unicode characters or with an equivalent ASCII-only name beginning with “xn--”. Considerations: The “xn--” spelling of a domain name is an underlying technical detail. Ideally, the user never needs to see it. However, in a transition time where not every email system supports internationalized email addresses, the “xn--” spelling might be a useful workaround. Recommendations: Spell domain names with their internationalized non-ASCII names. Avoid displaying the “xn--” alternative name. Some email clients might not automatically link the U-label and A-label forms of email address mailbox names, so ensure that both labels are mapped to each other. Considerations for Naming Internationalized Email Mailboxes - Report UASG028 Page 15 Glossary Alias: An email address that delivers mail to the same place as another email address. Typically, an alias is an ASCII email address that provides a fallback address for an EAI address in case a correspondent cannot send to the EAI address due to delivery systems not supporting EAI. ASCII: Refers to a limited character set made up of Latin-script letters without accents, numeric digits, and a few punctuation marks. The term ASCII is a computer industry acronym. Display Name: The name that appears next to the email address. Domain name: the sequence of names used to identify a website or email server, e.g. “uasg.tech” or “icann.org”. EAI: Email Address Internationalization. Email Address Internationalization: The practice of email addresses that are made up of all practical languages and scripts, not just ASCII or Latin script. Equivalent: When two or more Unicode code points share one meaning or are linguistically deemed equivalent by local authorities, resulting in "character variants". For example, they occur between Simplified and Traditional Chinese scripts, and are potentially confusing to people who are using these scripts. IDN: Internationalized Domain Name. IME (input-method editor): IME is an application that allows a standard keyboard (such as a US-101 keyboard) to be used to type characters and symbols that are not directly represented on the keyboard itself. Internationalized Domain Name: a domain name with non-ASCII characters. Label Generation Rules: rules for the use of characters in domain names. LGRs: Label Generation Rules. Mailbox Name: The portion of an email address identifying the mailbox location under a domain name. Used interchangeably with other terminology such as “mailbox name”, “account name”, “username”, “UTF-8 part”, “local-part”. Punycode: an algorithm to encode Unicode in the limited ASCII character subset used for Internet hostnames. Phase 1 of EAI: an email system that can successfully send emails to and receive emails from, internationalized email addresses, but cannot host mailboxes with internationalized names. Phase 2 of EAI: an email system that can successfully host internationalized mailbox names and successfully send emails to and receive emails from, internationalized email addresses. Rendering: the process by which a computer display system turns a sequence of characters Considerations for Naming Internationalized Email Mailboxes - Report UASG028 Page 16 into a visual appearance on the screen. Script: the conventions and sets of characters used together to write one or more languages. Script.txt: The data files associated with the Unicode Character Database, identifying Script property values of all code points . Unicode: a character encoding standard, encompassing most of the world’s scripts and written languages. See  Variant names: names that are considered the “same” by the community. Considerations for Naming Internationalized Email Mailboxes - Report UASG028 Page 17

 Programming to Support Universal Acceptance of Domain Names and Email

Agenda


 ◉
 Introduction
 ◉
 

Overview of Universal Acceptance


 ◉
 

Fundamentals of Unicode


 ◉
 Fundamentals for IDNs and 

EAI


 ◉
 Programming for UA ⚪ Processing Domain Names ⚪ Processing 

Email Address


 ◉
 

Conclusion




 

Overview of Universal Acceptance



 

Categories of Domain Names and 

Email Address

es

 ◉
 It’s now possible to have domain names and email addresses in local languages using UTF8. ⚪ 

Internationalized Domain Names

 (IDNs) ⚪ 



Email Address Internationalization (EAI)

Domain names ⚪ Newer top-level domain names: ⚪ Longer top-level domain names: ⚪ 

Internationalized Domain Names

:
 ◉
 Internationalized email addresses (EAI) examples ⚪ ASCII@IDN ⚪ UTF8@ASCII ⚪ UTF8@IDN ⚪ UTF8@IDN; example.sky example.abudhabi 普遍接受-测试.世界
 marc@société.org ईमेल@example.com 测试@普遍接受-测试.世界 ‫ای‬-‫مثال @میل‬.‫موقع‬


 

Universal Acceptance and Digital Inclusion


 ◉
 Many people around the world are currently excluded from experiencing the full benefits of the Internet simply because they’re unable to use a domain name or email address of choice in their language and script
 ◉
 For example, a valid email is rejected by a form in a website (and also incorrectly displayed from left to right instead of RTL):


 

Universal Acceptance of Domain Names and Email


 Goal All domain names and email addresses work in all software applications. .‫أن تعمل جمیع أسماء النطاقات وعناوین البرید اإللكتروني في جمیع التطبیقات البرمجیة‬
 Impact Promote consumer choice, improve competition, and provide broader access to end users.


 What are the advantages/importance of being UA ready?
 For students
 Developers
 Governments
 Businesses


 

Scope of UA Readiness for Programmers


 ◉
 Support all Domain Names including 

Internationalized Domain Names

 (IDNs) and all 

Email Address

es, including Internationalized 

Email Address

es (

EAI

):
 Accept
 Validate
 Process
 Store
 Display
 ◉
 Accept: The user can input characters from their local script into a text field.
 ◉
 Validate: The software accepts the characters and recognizes them as valid.
 ◉
 Process: The system performs operations with the characters.
 ◉
 Store: The database can store the text without breaking or corrupting.
 ◉
 Display: When fetched from the database, the information is correctly shown.

 Question ◉
 To enhance systems to be Universal Acceptance (UA) ready, which of the following categories of domain names and email addresses are relevant? 1. ASCII domain names. 2. 

Internationalized Domain Names

 (IDNs). 3. Internationalized email addresses (

EAI

). 4. All the above. 5. Only 2 and 3.


 

Fundamentals of Unicode




 What do you know about ASCII and Unicode?


 
 

Character and Character Set

 ◉
 A label or string such as ‫أهال‬, नमस्ते, Hello is formed of characters. ⚪ Hello --> H e l l o
 ◉
 A character is unit of information used for the organization, control, or representation of textual data.
 ◉
 Examples of character: ⚪ Letters ⚪ Digits ⚪ Special characters i.e. Mathematical symbols , punctuation marks ⚪ Control Characters - typically not visible
 ◉
 American Standard Code for Information Interchange (ASCII) encodes characters used in computing including letters a-z, digits 0-9 and others.


 

Character Encoding

 Character encoding is a system used to convert characters (like letters, numbers, and symbols) into a format that computers can understand and process. Essentially, it assigns a unique number (or code) to each character.
 Encoding Schemes: schemes define how characters are encoded. Examples •
 ASCII: Uses 7 bits to represent characters, suitable for English text.
 •
 Unicode: Uses up to 32 bits, supporting characters from almost all languages and symbols.


 Hello World: Python print("Enter your input: ") inputstr = input() #default character encoding is UTF-8 print("Input data is: ") print(inputstr)


 Hello World: Java import java.util.Scanner; public class ReadWriteUnicode { public static void main(String[]args)
 {
 Scanner scr = new Scanner(System.in); System.out.println("Enter your input"); String Input = scr.nextLine(); //default character encoding is UTF-8
 System.out.println("Receieved input is: "+Input); } }


 Unicode Encoding – File Reading/Writing in Python ◉
 Read UTF-8 file file = open("filepath",'r',encoding='UTF-8') for line in file: print(line) file.close()
 ◉
 Write UTF-8 file file2 = open(“filepath",'w',encoding='UTF-8') data_to_write=‘‫'السالم عليكم‬ file2.writelines(data_to_write) file2.close()


 Unicode Encoding – File Reading in Java public void ReadFile(String filename){ try { FileInputStream fis = new FileInputStream(filename); InputStreamReader isr = new InputStreamReader(fis, StandardCharsets.UTF_8) BufferedReader br = new BufferedReader(isr); String line =""; while((line = br.readLine())!=null) { System.out.println(line); } fis.close(); }catch(IOException ex) { System.err.println(ex.toString()); } }

 Unicode Encoding – File Writing in Java public void WriteFile(String filename, String text){ try{ FileOutputStream fis = new FileOutputStream(filename);
 OutputStreamWriter osw = new OutputStreamWriter(fis,StandardCharsets.UTF_8); BufferedWriter bw = new BufferedWriter(osw); bw.write(text); bw.flush(); fis.close(); }catch(IOException ex) { System.err.println(ex.toString());
 }
 }


 

Normalization


 ◉
 There are multiple ways to encode certain glyphs in Unicode: ⚪ è = U+00E8 ⚪ e + ` = è = U+0065 + U+0300 ⚪ ‫ =آ‬U+0622 ⚪ ٓ + ‫=ا =ا‬U+0627 U+0653
 ◉
 The following string can exist in corpus in the form of first string below, whereas input string is in the form of second string, below. So, search result will be empty. ⚪ ‫(آدم‬U+0622 U+062F U+0645) ⚪ ‫(ادم‬U+0627 U+0653 U+062F U+0645)
 ◉
 For searching , sorting and any string operations we need normalization.
 ◉
 

Normalization

 ensures that the end representation is the same, even if users type differently


 

Normalization


 ◉
 Different normalization forms defined by Unicode are listed below: ⚪ 

Normalization

 Form D (NFD) ⚪ 

Normalization

 Form C (NFC) ⚪ 

Normalization

 Form KD (NFKD) ⚪ 

Normalization

 Form KC (NFKC)
 ◉
 In domain names NFC is used.


 

Normalization

 Code - Python import unicodedata input_str = input() # take input from user normalized_input = unicodedata.normalize('NFC',input_str) #normalize user input print(normalized_input)


 

Normalization

 Code - Java import com.ibm.icu.text.Normalizer2 Scanner sc = new Scanner(System.in); Normalizer2 norm = Normalizer2.getNFCInstance(); //get NFC object String input; input = sc.nextline(); String normalized_input = norm.normalize(input);


 

Internationalized Domain Names




 Two equivalent forms of IDN domain labels
 www.exâmple.ca
 U-Label
 A-Label
 Human users
 Applications or systems internally
 (using UTF-8 format
 ASCII
 E.g. exâmple
 e.g. xn----f38am99bqvcd5liy1cxsg


 Converting U-label to A-label
 Take user input and normalize and check against IDNA2008 to form IDN U-label. • exâmple
 Convert U-label to punycode (using RFC3492). • exmple-xta • --f38am99bqvcd5liy1cxsg
 • 普遍接受-测试
 ◉
 Add the “xn--” prefix to identify the ASCII string as an IDN A-label. • xn--exmple-xta • xn----f38am99bqvcd5liy1cxsg
 Use the latest IDN standard called IDNA2008 for IDNs. ⚪ Do not use libraries for the outdated IDNA2003 version.

 Convert U-Label => A-Label: Python import unicodedata #library for normalization import idna #library for conversion domainName = '‫صحة‬.‫'مصر‬ try: domainName_normalized = unicodedata.normalize('NFC', domainName) #normalize to NFC print(domainName_normalized) domainName_alabel = idna.encode(domainName_normalized).decode("ascii") #U-label to A-label print(domainName_alabel) domainName_ulabel = idna.decode(domainName_alabel) print(domainName_ulabel) except idna.IDNAError as e: print("Domain '{domainName}' is invalid: {e}") #invalid domain as per IDNA 2008 except Exception as e: print("ERROR: {e}")


 Convert U-Label => A-Label: Java ◉
 International Components for Unicode (ICU).
 ◉
 The gold standard library for Unicode. It was developed by IBM and is now managed by Unicode. In sync with Unicode standards. ⚪ IDNA Conversion is based on Unicode UTS46, which supports transition from IDNA2003 to IDNA2008. However, it is possible to configure not to support transition (recommended). ⚪ IDNA Conversion includes normalization as per IDNA (good!). ⚪ Check if there are errors in the conversion by calling info.hasErrors(). ⚪ For IDNs, set the options to restrict the validation and use to IDNA2008. ⚪ The static methods implement IDNA2003, and non-static methods implement IDNA2008.


 Convert U-Label => A-Label: Java import com.ibm.icu.text.IDNA; public static String convertULabeltoALabel(String Ulabel) { String Alabel = ""; final IDNA idnaInstance = IDNA.getUTS46Instance(IDNA.NONTRANSITIONAL_TO_ASCII | IDNA.CHECK_BIDI | IDNA.CHECK_CONTEXTJ | IDNA.CHECK_CONTEXTO | IDNA.USE_STD3_RULES);
 StringBuilder output = new StringBuilder(); IDNA.Info info = new IDNA.Info(); idnaInstance.nameToASCII(Ulabel, output, info); Alabel = output.toString(); if (!info.hasErrors()) { return Alabel; } else { //Conversion fails return info.getErrors().stream().toString(); } }

 Convert U-Label => A-Label: Java import com.ibm.icu.text.IDNA; public static String convertALabeltoULabel(String Alabel) { String Ulabel = ""; final IDNA idnaInstance = IDNA.getUTS46Instance(IDNA.NONTRANSITIONAL_TO_ASCII | IDNA.CHECK_BIDI | IDNA.CHECK_CONTEXTJ | IDNA.CHECK_CONTEXTO | IDNA.NONTRANSITIONAL_TO_UNICODE | IDNA.USE_STD3_RULES); StringBuilder output = new StringBuilder(); IDNA.Info info = new IDNA.Info(); idnaInstance.nameToUnicode(Alabel, output, info); Ulabel = output.toString(); if (!info.hasErrors()) { return Ulabel; } else { return info.getErrors().stream().toString(); } }


 

Domain Name Validation




 Validating Domain Name ◉
 Validating syntax: ⚪
 ASCII: RFC1035 • Composed of letters, digits, and hyphen. • Max length is 255 octets with each label up to 63 octets.
 ⚪
 IDN: IDNA2008 (RFCs 5890-5894) • Valid A-labels • Valid U-labels


 Validate Domain Name: Python import unicodedata #library for normalization import idna #library for conversion domainName = '‫صحة‬.‫'مصر‬ try: domainName_normalized = unicodedata.normalize('NFC', domainName) #normalize to NFC print(domainName_normalized) #U-label to A-label domainName_alabel = idna.encode(domainName_normalized).decode("ascii") print(domainName_alabel) except idna.IDNAError as e: #invalid domain as per IDNA 2008 print("Domain '{domainName}' is invalid: {e}") except Exception as e: print("ERROR: {e}")


 Validate Domain Name: Java import com.ibm.icu.text.IDNA; public static boolean isValidDomain(String DomainName) { String Alabel = ""; final IDNA idnaInstance = IDNA.getUTS46Instance(IDNA.NONTRANSITIONAL_TO_ASCII | IDNA.CHECK_BIDI | IDNA.CHECK_CONTEXTJ | IDNA.CHECK_CONTEXTO | IDNA.USE_STD3_RULES); StringBuilder output = new StringBuilder(); IDNA.Info info = new IDNA.Info(); idnaInstance.nameToASCII(DomainName, output, info); Alabel = output.toString(); if (!info.hasErrors()) { return true; } else { //Conversion fails return false; } }

 

Domain Name Resolution




 

Domain Name Resolution

 ◉
 After validation, a software would then use the domain name identifier as: ⚪ A domain name to be resolved in the DNS.
 ◉
 Traditional way of doing hostname resolution and sockets resolution cannot be used for IDNs.
 ◉
 We need to do following: 1. Take user input and normalize 2. Convert U-label to A-label (IDNA2008) 3. Use A-label for hostname resolution


 

Domain Name Resolution

 – Python import socket import unicodedata import idna domainName='' try: #normalize domain Name domainName_normalized = unicodedata.normalize('NFC', domainName) #Convert U-label to A-label form domainName_alabelForm = idna.encode(domainName_normalized).decode("ascii") #get IP address of the domain ip = socket.gethostbyname(domainName_alabelForm) print(ip) except Exception as ex: print(ex)


 

Domain Name Resolution

 – Java ◉
 

Normalization

 and U-label to A-label conversion is same as discussed before.
 import java.net.InetAddress; try { InetAddress ad = InetAddress.getByName(domainNameAlabelForm); String ip = ad.getHostAddress(); // returns ip for domain System.out.println(ip);
 } catch (Exception ex) { System.out.println(ex.toString()); //Unknown host exception }


 

Domain Name Storage

 ◉
 We need to ensure that database supports and configure for UTF-8.
 ◉
 SQL, e.g., MySQL, Oracle, Microsoft SQL Server. ⚪ Set domain names to max: 255 octets, 63 octets per label. • In UTF-8 native, variable length. ⚪ Recommendation to use variable length String columns. ⚪ Consider/verify the object-relational mapping (ORM) driver/tool if you are using one.
 ◉
 noSQL, e.g., MongoDB, CouchDB, Cassandra, HBase, Redis, Riak, Neo4J. ⚪ Already UTF-8 variable length.
 1.
 Store and retrieve either U-label or A-label in a field consistently.
 2.
 You can also store both U-label and A-label in separate fields.


 



Email Address

 Internationalization (

EAI

)




 

Email Address

 ◉
 Email address syntax: mailboxName@domainName. ⚪ Email has a mailboxName. ⚪ Email has a domainName. • The domainName can be ASCII or IDN. • For example: myname@example.org myname@xn--exmple-xta.ca


 

EAI

 ◉
 

EAI

 has the mailboxName in Unicode (in UTF-8 format).
 ◉
 The domainName can be ASCII or IDN. ⚪ For example: • kévin@example.org • すし@ xn--exmple-xta.ca • すし@快手.游戏.


 

Email Address

es Form ◉
 name@exâmple.ca and name@xn--exmple-xta.ca represent equivalent email address.
 ◉
 Application should be able to treat both forms as equivalent.
 ◉
 Internally consistently use A-label or U-label, but don’t mix A-label and U-label.
 ◉
 Technical Recommendation: Backend processing should be in A-label, and U-label for visual inspection.
 ◉
 For example, new user registration in application with equivalent A-label.


 Email Validation: Email Regular Expressions (Regex)
 ◉
 Basic: something@something. ⚪ ^(.+)@(.+)$
 ◉
 From owasp.org (security): ⚪ [^[a-zA-Z0-9_+&*-]+(?:\.[a-zA-Z0-9_+&*-]+)*@(?:[a-zA-Z0-9-]+\.)+[a-zA-Z]{2,7}$]. • Does not support 

EAI

, i.e., mailbox name in UTF8 not allowed: [a-zA-Z0-9_+&*-]. • Does not support ASCII TLD longer than 7 characters: [a-zA-Z]{2,7}. • Does not support U-labels in IDN TLD: [a-zA-Z]. ⚪ But OWASP is THE reference for security. • Therefore, you may end up fighting with your security team to use a UA-compatible Regex instead of the “standard” one from OWASP.


 Email Regular Expressions (Regex) ◉
 Example of Regex suggested in various forums: ex: List of proposals ⚪ ^[A-Za-z0-9+_.-]+@(.+)$ does not support UTF8 in mailbox name. ⚪ ^[a-zA-Z0-9_!#$%&’*+/=?`{|}~^.-]+@[a-zA-Z0-9.-]+$ does not support U-labels. ⚪ ^[a-zA-Z0-9_!#$%&’*+/=?`{|}~^-]+(?:\\.[a-zA-Z0-9_!#$%&’*+/=?`{|}~^-]+)*@[a-zA-Z0-9]+(?:\\.[a-zA-Z0-9-]+)*$ does not support U-labels. ⚪ ^[\\w!#$%&’*+/=?`{|}~^-]+(?:\\.[\\w!#$%&’*+/=?`{|}~^-]+)*@(?:[a-zA-Z0-9-]+\\.)+[a-zAZ]{2,6}$ have length restrictions for the TLD between 2 – 6 characters.
 ◉
 One can come up with an 

EAI

-IDN compatible regex using various Unicode codepoints characteristics. ⚪ For IDN it would be like a reimplementation of the IDNA protocol tables in regex!
 ◉
 Given that both sides of an 

EAI

 may have UTF8, then one regex for an 

EAI

 could be .*@.* which is only verifying the presence of the ‘@’ character.


 

Validate Email




 

Email Address

es Validation ◉
 Email has a mailboxName.
 ◉
 Email has a domainName.
 ◉
 DomainName validation same as before.
 ◉
 mailboxName validation require a valid UTF8 String.
 ◉
 Local administrator defines policy for mailboxName. ⚪ Gmail policy: firstname.lastname@gmail.com is equivalent to firstnamelastname@gmail.com.
 ◉
 Guidelines for mailboxName are available by UASG.


 

EAI

 Validation - Python from email_validator import validate_email,EmailNotValidError logger = logging.getLogger(__name__) try: # As part of process it performs DNS resolution # Normalizes email addresses automatically # Supports internationalized domain names validated = validate_email(email_address, check_deliverability=True) print(validated) logger.info("'{address}' is a valid email address") print("'{address}' is a valid email address") except EmailNotValidError as e: print("'{address}' is not a valid email address: {e}") except Exception as ex: print("Unexpected Exception")


 

EAI

 Validation - Java ◉
 Apache Common Validator: ⚪ Has domain and email validators. ⚪ Do not use as it relies on a static list of TLDs! OUTDATED!


 

EAI

 Validation - Java /** * Download the list of TLDs on ICANN website */ public static String[] retrieveTlds() { String IANA_TLD_LIST_URL = "https://data.iana.org/TLD/tlds-alpha-by-domain.txt"; StringBuilder out = new StringBuilder(); try (BufferedInputStream in = new BufferedInputStream( new URL(IANA_TLD_LIST_URL).openStream())) { byte[] dataBuffer = new byte[1024]; int bytesRead; while ((bytesRead = in.read(dataBuffer, 0, 1024)) != -1) { out.append(new String(dataBuffer, 0, bytesRead)); } } catch (IOException e) { // handle exception } return Arrays.stream(out.toString().split("\n")) .filter(s -> !s.startsWith("#")) .map(String::toLowerCase).distinct().toArray(String[]::new); }

 

EAI

 Validation - Java public static DomainValidator createDomainValidatorInstance(String domain, boolean use_actual_domains) { List<Item> domains = new ArrayList<>(); if (use_actual_domains) { domains.add(new Item(GENERIC_PLUS, retrieveTlds())); } else { String tld = domain; if (domain.contains(".")) { tld = domain.substring(domain.lastIndexOf(".") + 1); } // Convert TLD to A-Label String domainConverted = convertULabeltoALabel(tld); // if there is an error, do nothing, validator will fail if (domainConverted!="") { domains.add(new Item(GENERIC_PLUS, new String[]{domainConverted})); } } return DomainValidator.getInstance(false, domains); }

 

EAI

 Validation - Java public static boolean isValidEmail(String emailaddress){ emailaddress = Normalizer2.getNFCInstance().normalize(emailaddress); String[]emailparts = emailaddress.split("@"); if(emailparts.length==2){ String mailboxname = emailparts[0]; String domainName = emailparts[1]; String domainNameAlabelForm =convertULabeltoALabel(domainName); try { EmailValidator em = new EmailValidator(false, false, createDomainValidatorInstance(domainName,true)); if(em.isValid(mailboxname+"@"+domainNameAlabelForm)){ return true; } return false; } catch (Exception ex) { System.out.println(ex.toString()); return false; } } else{ return false; } }


 

Sending and Receiving Email




 Sending and Receiving ◉
 We need to be able to send to either form: ⚪ mailboxName-UTF-8@A-labelform. ⚪ mailboxName-UTF-8@U-labelform.
 ◉
 We need to be able to receive to either form: ⚪ mailboxName-UTF-8@A-labelform. ⚪ mailboxName-UTF-8@U-labelform.
 ◉
 Storage of email should be consistent with domain name in either A-label or U-label form.
 ◉
 Backend send/receive should be managed by mail server.
 ◉
 Handover process (Front end application 🡪 email server). ⚪ Libraries used in handover process should be 

EAI

 Compliant. ⚪ Mail server should also be 

EAI

 compatible. • How to make mail server 

EAI

 compatible is out of scope of this training?


 Sending and Receiving – Python ◉
 Smtplib can be used to send 

EAI

-compliant emails.
 ◉
 It does not validate the domain compliance with IDNA 2008, therefore another validation method should be used before trying to send an email. ⚪ For instance, using the email-validator library.


 Sending and Receiving – Python try: to = 'kévin@example.com' local_part, domain = to.rsplit('@', 1) domain_normalized= unicodedata.normalize('NFC',domain)#normalize domain name to = '@'.join((local_part,idna.encode(domain_normalized).decode('ascii’)))#convert U-label to A-label validated = validate_email(to, check_deliverability=True) #validate email address if validated: host='' port='' smtp = smtplib.SMTP(host, port) smtp.set_debuglevel(False) smtp.login(‘useremail’,’password') sender=‘ua@test.org' subject='hi' content='content here' msg = EmailMessage() msg.set_content(content) msg['Subject'] = subject msg['From'] = sender msg['to']=to smtp.send_message(msg, sender, to) smtp.quit() logger.info("Email sent to '{to}'") except smtplib.SMTPNotSupportedError: # The server does not support the SMTPUTF8 option, you may want to perform downgrading logger.warning("The SMTP server {host}:{port} does not support the SMTPUTF8 option") raise


 Sending and Receiving – Java ◉
 Jakarta Mail can be used for sending email.
 import import import import import import import import import import
 com.sun.mail.smtp.SMTPTransport; jakarta.mail.Message; jakarta.mail.MessagingException; jakarta.mail.PasswordAuthentication; jakarta.mail.Session; jakarta.mail.Transport; jakarta.mail.internet.InternetAddress; jakarta.mail.internet.MimeMessage; java.util.Date; java.util.Properties;


 Sending and Receiving – Java public static boolean sendEmail(String to, String host, String sender, String subject, String content,String username,String password){ if(isValidEmail(to)) { Properties props =
 new Properties();
 props.put("mail.smtp.host", host); props.put("mail.smtp.port", "587"); props.put("mail.smtp.auth", "true"); props.put("mail.smtp.starttls.enable", "true"); // enable UTF-8 support, mandatory for 

EAI

 support props.put("mail.mime.allowutf8", true); Session session = Session.getInstance(props, new jakarta.mail.Authenticator() { protected PasswordAuthentication getPasswordAuthentication() { return new PasswordAuthentication(username, password); } });


 Sending and Receiving – Java(2) /* * Jakarta mail is 

EAI

 compliant with 2 issues: * - it rejects domains that are not NFC normalized * - it rejects some unicode domains * In such case, first try to normalize, then convert domain to A-label. We do normalization * first to get an email address the closest possible to the user input because once * converted in A-label it may be displayed as is to the user. */
 String[] add_parts = to.split("@"); String mailboxName = add_parts[0]; String domainName = add_parts[1];
 String domainNameNormalized =Normalizer2.getNFCInstance().normalize(domainName); String domainNameAlabelForm = convertULabeltoALabel(domainNameNormalized); String compliantTo = mailboxName+"@"+domainNameAlabelForm;


 Sending and Receiving – Java(3) try (Transport transport = session.getTransport()) { if (transport instanceof SMTPTransport && !((SMTPTransport) transport).supportsExtension("SMTPUTF8")) { try { MimeMessage message = new MimeMessage(session); //set message headers for internationalized content message.addHeader("Content-type", "text/HTML; charset=UTF-8"); message.addHeader("Content-Transfer-Encoding", "8bit"); message.addHeader("format", "flowed"); message.setFrom(new InternetAddress(sender)); message.setSubject(subject, "UTF-8"); message.setText(content, "UTF-8"); message.setSentDate(new Date()); message.setRecipient(Message.RecipientType.TO, new InternetAddress(compliantTo)); Transport.send(message); return true; } catch (Exception e) { System.out.println(String.format("Failed to send email to %s: %s", to, e)); } } else { return false;} } catch (MessagingException e) { // ignore } } return false;}


 

Conclusion




 Prog. Languages Support UASG018A – note that some have improved since.


 

Conclusion


 ◉
 Be aware that UA identifiers may not be fully supported in software and libraries.
 ◉
 Use the right libraries and frameworks.
 ◉
 Adapt your code to properly support UA.
 ◉
 Do unit and system testing using UA test cases to ensure that your software is UA ready.